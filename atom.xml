<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>白告山风</title>
  
  <subtitle>不定期更新摄影，acm题解等等有趣的东西~</subtitle>
  <link href="http://onem.cloud/atom.xml" rel="self"/>
  
  <link href="http://onem.cloud/"/>
  <updated>2023-01-22T10:29:43.114Z</updated>
  <id>http://onem.cloud/</id>
  
  <author>
    <name>Mr.白</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>拓扑排序专题（初稿）</title>
    <link href="http://onem.cloud/2023/01/21/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98%EF%BC%88%E5%88%9D%E7%A8%BF%EF%BC%89/"/>
    <id>http://onem.cloud/2023/01/21/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98%EF%BC%88%E5%88%9D%E7%A8%BF%EF%BC%89/</id>
    <published>2023-01-21T15:54:51.000Z</published>
    <updated>2023-01-22T10:29:43.114Z</updated>
    
    <content type="html"><![CDATA[<p>基本思路：每次寻找一个入度（前驱为0）的点进入答案队列之后，然后所有前驱为它的点的入度减一，然后循环继续找入度为0的点。这里要特别指出，当有向图内存在环的时候，最后查询结束之后，答案队列中的元素个数会少于总共的点数。</p><h4 id="例题1："><a href="#例题1：" class="headerlink" title="例题1："></a>例题1：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Problem Description</span><br><span class="line">有N个比赛队（1&lt;=N&lt;=500），编号依次为1，2，3，。。。。，N进行比赛，比赛结束后，裁判委员会要将所有参赛队伍从前往后依次排名，但现在裁判委员会不能直接获得每个队的比赛成绩，只知道每场比赛的结果，即P1赢P2，用P1，P2表示，排名时P1在P2之前。现在请你编程序确定排名。</span><br><span class="line"></span><br><span class="line">Input</span><br><span class="line">输入有若干组，每组中的第一行为二个数N（1&lt;=N&lt;=500），M；其中N表示队伍的个数，M表示接着有M行的输入数据。接下来的M行数据中，每行也有两个整数P1，P2表示即P1队赢了P2队。</span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line">给出一个符合要求的排名。输出时队伍号之间有空格，最后一名后面没有空格。</span><br><span class="line"></span><br><span class="line">其他说明：符合条件的排名可能不是唯一的，此时要求输出时编号小的队伍在前；输入数据保证是正确的，即输入数据确保一定能有一个符合要求的排名。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入样例</span><br><span class="line">4 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">4 3</span><br><span class="line"> </span><br><span class="line">输出样例</span><br><span class="line">1 2 4 3</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">508</span>;</span><br><span class="line"><span class="type">int</span> map1[maxn][maxn],indgr[maxn],res[maxn];<span class="comment">//map1是邻接矩阵，indgr[i]代表i点位置当前有几个前驱，res为输出数组</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;<span class="comment">//从小到大寻找 </span></span><br><span class="line"><span class="keyword">if</span>(!indgr[j])&#123;<span class="comment">//如果当前前驱点数为0， </span></span><br><span class="line">res[i]=j;<span class="comment">//记录当前点的编号</span></span><br><span class="line">indgr[j]--;</span><br><span class="line">k=j;<span class="comment">//保存当前点 </span></span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(map1[k][j])&#123;<span class="comment">//删除由当前点开始的所有边 </span></span><br><span class="line">map1[k][j]=<span class="number">0</span>;</span><br><span class="line">indgr[j]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">opt</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;n)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,res[i]);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">memset</span>(map1,<span class="number">0</span>,<span class="built_in">sizeof</span>(map1));</span><br><span class="line"><span class="built_in">memset</span>(indgr,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">int</span> p1,p2;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;p1,&amp;p2);<span class="comment">//p1-&gt;p2</span></span><br><span class="line"><span class="keyword">if</span>(!map1[p1][p2])&#123;<span class="comment">//防止重边 </span></span><br><span class="line">map1[p1][p2]=<span class="number">1</span>;</span><br><span class="line">indgr[p2]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">topsort</span>(n);</span><br><span class="line"><span class="built_in">opt</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="例题2："><a href="#例题2：" class="headerlink" title="例题2："></a>例题2：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Problem Description</span><br><span class="line">甘晨煜是一家软件公司的创始人，人称“甘老板”。</span><br><span class="line"></span><br><span class="line">经过几年的努力，公司已经准备在纳斯达克上市，甘老板自然也是心情大好。随着中秋节的临近，甘老板决定为员工们每人发个红包。</span><br><span class="line"></span><br><span class="line">现在的问题是，每人发多少红包呢？要知道，很多员工提出了自己的要求，比如，胡承轩就提出他的红包应该比麻致远的大！</span><br><span class="line"></span><br><span class="line">为了图吉利，甘老板决定为每名员工至少发888的红包，同时，他还希望能满足员工们提出的所有的要求，当然，最后是希望发出红包的总金额最少。</span><br><span class="line"></span><br><span class="line">Input</span><br><span class="line">输入包含多组测试数据。</span><br><span class="line">每组数据第一行首先是两个整数n和m，分别表示员工的人数是n，员工们一共提出了m条要求。</span><br><span class="line">接着的m行，每行包含2个整数a和b，表示一条要求：a的红包应该比b的大。</span><br><span class="line"></span><br><span class="line">n&lt;=10000</span><br><span class="line">m&lt;=20000</span><br><span class="line">员工编号a和b不等，且都在区间[1,n]内</span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line">对于每组测试数据，请输出甘老板总共最少需要发出多少金额的红包。</span><br><span class="line">如果不能满足员工提出的全部的要求，直接输出-1即可。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入样例</span><br><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">2 2</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">输出样例</span><br><span class="line">1777</span><br><span class="line">-1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="源码：-1"><a href="#源码：-1" class="headerlink" title="源码："></a>源码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span>+<span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; map1[N];</span><br><span class="line"><span class="type">int</span> indgr[N],money[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//遍历money </span></span><br><span class="line"><span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!indgr[j])&#123;</span><br><span class="line">indgr[j]--;</span><br><span class="line">k=j;</span><br><span class="line">num++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;map1[k].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line"><span class="type">int</span> remain=map1[k][j];</span><br><span class="line">indgr[remain]--;</span><br><span class="line">money[remain]=<span class="built_in">max</span>(money[remain],money[k]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(num==n)&#123;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">ans+=<span class="number">888</span>+money[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">map1[i].<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(indgr,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line"><span class="built_in">memset</span>(money,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);<span class="comment">//b-&gt;a 888-&gt;889</span></span><br><span class="line">map1[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">indgr[a]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">topsort</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;前言：&lt;/strong&gt; 拓扑排序，听上去似乎不容易理解什么意思，大概意思大概为对一个有向无环图的所有点，按照它们的相对位置关系，排成一个队列，通常这个队列不唯一。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://onem.cloud/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="拓扑排序" scheme="http://onem.cloud/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>最短路径算法专题（初稿）</title>
    <link href="http://onem.cloud/2023/01/21/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E5%88%9D%E7%A8%BF%EF%BC%89/"/>
    <id>http://onem.cloud/2023/01/21/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E5%88%9D%E7%A8%BF%EF%BC%89/</id>
    <published>2023-01-21T14:21:38.000Z</published>
    <updated>2023-01-22T09:20:19.256Z</updated>
    
    <content type="html"><![CDATA[<p>​基本思路：首先从起点到所有可达的边进行查找，看是否能更新dist数组（dist[i]代表从源点到第i点的当前最短距离），同时在所有dist[i]中选择一个还没找到最短距离的点但是当前dist[i]是最短的点作为下次的起点，同时代表该点的最短距离被找到。一直循环，直到到达终点。每轮都能找到一个点的最短距离。</p><h4 id="模板："><a href="#模板：" class="headerlink" title="模板："></a>模板：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> dist[N],map1[N][N],pre[N];<span class="comment">//dist[i]代表从起点到i点的当前最短距离，map1是邻接矩阵，pre[i]代表第i点的前一个点。</span></span><br><span class="line"><span class="type">int</span> start,targe,n;<span class="comment">//start是起点，targe是终点。n是点的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;start,&amp;targe);</span><br><span class="line"><span class="comment">//初始化dist和map每个元素都是inf，pre[i]=i,visit[i][j]=1</span></span><br><span class="line"><span class="comment">//建图 map[i][j]=min(map[i][j],dis);防止重边</span></span><br><span class="line">dist[start]=<span class="number">0</span>,visit[start]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(start!=targe)&#123;</span><br><span class="line"><span class="type">int</span> min=inf;</span><br><span class="line"><span class="type">int</span> next=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(map[start][i]!=inf)&#123;</span><br><span class="line"> <span class="keyword">if</span>(dist[i]&gt;map[start][i]+dist[start])&#123;</span><br><span class="line"> dist[i]=map[start][i]+dist[start];<span class="comment">//从源点到i的距离存在更短距离时，更新dist数组</span></span><br><span class="line"> pre[i]=start;<span class="comment">//保存前驱</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(visit[i]&amp;&amp;dist[i]&lt;min)&#123;<span class="comment">//在还没找到最短距离的点找出到源点距离最短的</span></span><br><span class="line">next=i;</span><br><span class="line">min=dist[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(min==inf)<span class="keyword">break</span>;<span class="comment">//如果当前没能找到可以更新的点则退出循环。</span></span><br><span class="line">start=next,visit[start]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">opt</span><span class="params">(<span class="type">int</span> *pre,<span class="type">int</span> end)</span></span>&#123;<span class="comment">//输出最短路径队列</span></span><br><span class="line"> <span class="keyword">if</span>(pre[end]!=end)<span class="built_in">opt</span>(pre,pre[end]);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​由上面的模板可以看出，我们朴素的dijkstra算法的时间复杂度大致为O(N^2),我们会发现，我们主要在邻接矩阵从起点，寻找可达的下一个点浪费了时间，以及寻找dist数组中的最小值时浪费了时间，那我们有什么办法可以将这个O(N)的遍历过程优化为O(logN)呢？</p><p>首先我们先解决邻接矩阵空间利用率低下而且遍历效率低下的问题，由于这里只需要我们找到可到的点，我们不妨用单链表将第一个点可以到的所有点串在一起，这样就减少了从一个点出发漫无目的的搜索，这里的单链表可以用动态数组vector定义一个数组map1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">6</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">roadmode</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,dis;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;roadmode&gt; map1[N];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;map1[start].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    <span class="comment">//map1[start][i]即为所有从start出发可以到达的点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者我们还可以用链式前向星（下源码实现便是用的链式前向星）</p><p>接着我们还需要解决dist数组每轮寻找最小值需要消耗O(N)的问题，这个问题也很好解决，我们不妨维护一个小顶堆，配合一个vis数组即可解决。下面看具体实现代码。</p><h4 id="dijkstra的堆优化："><a href="#dijkstra的堆优化：" class="headerlink" title="dijkstra的堆优化："></a>dijkstra的堆优化：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span><span class="comment">//邻接表加堆优化的dijkstra算法 </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn1=<span class="number">100004</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn2=<span class="number">200004</span>;</span><br><span class="line"><span class="type">int</span> head[maxn1],dist[maxn1],visit[maxn1];<span class="comment">//head[i]代表从i可达的第一条边在edge数组里的下标</span></span><br><span class="line"><span class="type">int</span> cnt,s,n,m;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line"><span class="type">int</span> to,dis,next;<span class="comment">//to代表下一个点，dis代表距离，next代表从同一个点出发的下一条路在egde数组里的下标</span></span><br><span class="line">&#125;ID_Edge;<span class="comment">//链式前向星的邻接表的基础元素，其中next相当于单链表中的指针部分 </span></span><br><span class="line"></span><br><span class="line">ID_Edge edge[maxn2];<span class="comment">//存放边的信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add_edge</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to,<span class="type">int</span> dis)</span></span>&#123;<span class="comment">//增加一条边</span></span><br><span class="line">edge[++cnt].to=to;</span><br><span class="line">edge[cnt].dis=dis;</span><br><span class="line">    </span><br><span class="line">edge[cnt].next=head[from];<span class="comment">//下面这两句类似于头插法</span></span><br><span class="line">head[from]=cnt;</span><br><span class="line">&#125;<span class="comment">//链式前向星（类似维护多个单链表，且采用的是头插法） </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="type">int</span> id,dis;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node &amp;a) <span class="type">const</span>&#123;<span class="comment">//重载运算符 定义为对象的dis变量越小优先度越高</span></span><br><span class="line"><span class="keyword">return</span> a.dis&lt;dis;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;<span class="comment">//堆优化的基本元素---利用优先队列 实现查询O(1),维护O(logn)的复杂度 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">priority_queue&lt;Node&gt;q;<span class="comment">//优先队列默认为小顶堆</span></span><br><span class="line">q.<span class="built_in">push</span>((Node)&#123;s,<span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">dist[i]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">dist[s]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">Node a=q.<span class="built_in">top</span>();<span class="comment">//每次查询堆优化的dist队列中的最小值</span></span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(visit[a.id])&#123;<span class="comment">//如果这个最小值早找到了最短路径，则跳过</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">visit[a.id]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[a.id];i!=<span class="number">0</span>;i=edge[i].next)&#123;<span class="comment">//i代表从当前起点到另一点的边在edge里的下标</span></span><br><span class="line"><span class="keyword">if</span>(dist[edge[i].to]==<span class="number">-1</span>||(dist[a.id]+edge[i].dis&lt;dist[edge[i].to]))&#123;<span class="comment">//如果dist[edge[i].to]还没被到达过，或者存在更短的dist[edge[i].to]，就更新。</span></span><br><span class="line">dist[edge[i].to]=dist[a.id]+edge[i].dis;</span><br><span class="line">q.<span class="built_in">push</span>((Node)&#123;edge[i].to,dist[edge[i].to]&#125;);<span class="comment">//入堆</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"> <span class="type">int</span> u,v,w;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line"> <span class="built_in">Add_edge</span>(u,v,w);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">dijkstra</span>();</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,dist[i]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><del>我们不难发现</del>，堆优化后，时间复杂度大概为O(Nlog(N))<del>（我不知道为什么呜呜）</del>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;：最短路径算法，也称dijkstra算法，是从一个顶点到其余各顶点的最短路径算法，解决的是有权图中最短路径问题。迪杰斯特拉算法主要特点是从起始点开始，采用贪心算法的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止。&lt;/p&gt;</summary>
    
    
    
    <category term="Luogu" scheme="http://onem.cloud/categories/Luogu/"/>
    
    <category term="题解" scheme="http://onem.cloud/categories/Luogu/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="dijkstra" scheme="http://onem.cloud/tags/dijkstra/"/>
    
    <category term="dijkstra的堆优化" scheme="http://onem.cloud/tags/dijkstra%E7%9A%84%E5%A0%86%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>STL-堆与栈（初稿）</title>
    <link href="http://onem.cloud/2023/01/21/STL-%E5%A0%86%E4%B8%8E%E6%A0%88%EF%BC%88%E5%88%9D%E7%A8%BF%EF%BC%89/"/>
    <id>http://onem.cloud/2023/01/21/STL-%E5%A0%86%E4%B8%8E%E6%A0%88%EF%BC%88%E5%88%9D%E7%A8%BF%EF%BC%89/</id>
    <published>2023-01-21T11:38:32.000Z</published>
    <updated>2023-01-22T09:36:56.800Z</updated>
    
    <content type="html"><![CDATA[<h4 id="例题1：火车进站问题"><a href="#例题1：火车进站问题" class="headerlink" title="例题1：火车进站问题"></a>例题1：火车进站问题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Problem Description</span><br><span class="line">假设杭州东火车站只有一条铁路，并且所有火车都从一侧进来，从另一侧出去。那么，如果火车A先进站，然后火车B在火车A离开之前就进站，那么火车A直到火车B离开后才能离开，可参见下图。</span><br><span class="line"></span><br><span class="line">现在，假设车站中有n（n&lt;=9）列火车，所有火车都有一个ID（从1到n的编号），火车以O1的顺序进站，您的任务是确定火车是否可以按O2顺序出站。</span><br><span class="line"></span><br><span class="line">Input</span><br><span class="line">输入包含几个测试用例。</span><br><span class="line"></span><br><span class="line">每个测试用例均包含三部分：一个表示火车数量的整数和两个字符串O1和O2，其中，火车的进站顺序用O1串表示，火车的出站顺序用O2串表示。</span><br><span class="line"></span><br><span class="line">输入在文件末尾终止，更多信息参见样例。</span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line">如果不能从O1的入站顺序得到O2的出站顺序，请输出字符串“ No.”。</span><br><span class="line"></span><br><span class="line">如果能够得到，则请输出”Yes.”</span><br><span class="line">然后输出进站和出站的具体方式（“in”表示火车进站，“out”表示火车出站）。</span><br><span class="line">在每个测试用例之后输出一行“ FINISH”。</span><br><span class="line"></span><br><span class="line">更多信息参见样例。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入样例</span><br><span class="line">3 123 321</span><br><span class="line">3 123 312</span><br><span class="line">输出样例</span><br><span class="line">Yes.</span><br><span class="line">in</span><br><span class="line">in</span><br><span class="line">in</span><br><span class="line">out</span><br><span class="line">out</span><br><span class="line">out</span><br><span class="line">FINISH</span><br><span class="line">No.</span><br><span class="line">FINISH</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解题思路：用进栈出栈模拟进站出站。</p><h5 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">int main()&#123;</span><br><span class="line">while(cin&gt;&gt;n)&#123;</span><br><span class="line">string s1,s2;</span><br><span class="line">queue&lt;char&gt; q1,q2;</span><br><span class="line">queue&lt;string&gt;opt;</span><br><span class="line">stack&lt;char&gt; st;</span><br><span class="line">cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">q1.push(s1[i]);</span><br><span class="line">q2.push(s2[i]);</span><br><span class="line">&#125;</span><br><span class="line">while(!q1.empty())&#123;//确保车辆都进站了 </span><br><span class="line">while(!st.empty()&amp;&amp;st.top()==q2.front())&#123;</span><br><span class="line">opt.push(&quot;out&quot;);</span><br><span class="line">st.pop();</span><br><span class="line">q2.pop();</span><br><span class="line">&#125;//同时出栈出堆 </span><br><span class="line">char ch=q1.front();</span><br><span class="line">if(ch!=q2.front())&#123;</span><br><span class="line">st.push(ch);</span><br><span class="line">opt.push(&quot;in&quot;);</span><br><span class="line">q1.pop();//q1出堆入栈， </span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">opt.push(&quot;in&quot;);</span><br><span class="line">opt.push(&quot;out&quot;);</span><br><span class="line">q1.pop();</span><br><span class="line">q2.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">while(!q2.empty())&#123;</span><br><span class="line">if(q2.front()!=st.top())&#123;</span><br><span class="line">printf(&quot;No.\n&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">opt.push(&quot;out&quot;);</span><br><span class="line">st.pop();</span><br><span class="line">q2.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(st.size()==0)&#123;</span><br><span class="line">printf(&quot;Yes.\n&quot;);</span><br><span class="line">while(!opt.empty())&#123;</span><br><span class="line">cout&lt;&lt;opt.front()&lt;&lt;endl;</span><br><span class="line">opt.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;FINISH\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="例题2：括号匹配问题"><a href="#例题2：括号匹配问题" class="headerlink" title="例题2：括号匹配问题"></a>例题2：括号匹配问题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Problem Description</span><br><span class="line">I’m out of stories. For years I’ve been writing stories, some rather silly, just to make simple problems look difficult and complex problems look easy. But, alas, not for this one.</span><br><span class="line">You’re given a non empty string made in its entirety from opening and closing braces. Your task is to find the minimum number of “operations” needed to make the string stable. The definition for being stable is as follows:</span><br><span class="line"></span><br><span class="line">An empty string is stable.</span><br><span class="line">If S is stable, then &#123;S&#125; is also stable.</span><br><span class="line">If S and T are both stable, then ST (the concatenation of the two) is also stable.</span><br><span class="line">All of these strings are stable: &#123;&#125;, &#123;&#125;&#123;&#125;, and &#123;&#123;&#125;&#123;&#125;&#125;; But none of these: &#125;&#123;, &#123;&#123;&#125;&#123;, nor &#123;&#125;&#123;.</span><br><span class="line">The only operation allowed on the string is to replace an opening brace with a closing brace, or visa-versa.</span><br><span class="line">Input</span><br><span class="line">Your program will be tested on one or more data sets. Each data set is described on a single line. The line is a non-empty string of opening and closing braces and nothing else. No string has more than 2000 braces. All sequences are of even length.</span><br><span class="line">The last line of the input is made of one or more ’-’ (minus signs.)</span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line">For each test case, print the following line:</span><br><span class="line">k. N</span><br><span class="line">Where k is the test case number (starting at one,) and N is the minimum number of operations needed to convert the given string into a balanced one.</span><br><span class="line">Note: There is a blank space before N.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入样例</span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;&#125;&#123;&#125;&#123;&#125;</span><br><span class="line">&#123;&#123;&#123;&#125;</span><br><span class="line">---</span><br><span class="line">输出样例</span><br><span class="line">1. 2</span><br><span class="line">2. 0</span><br><span class="line">3. 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="源码：-1"><a href="#源码：-1" class="headerlink" title="源码："></a>源码：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string s;//贪心+模拟堆</span><br><span class="line">int id=1;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  while(cin&gt;&gt;s)&#123;</span><br><span class="line">  if(s[0]==&#x27;-&#x27;)break;</span><br><span class="line">  int num=0,l=0;//l指堆内左括号的个数，num指操作数 </span><br><span class="line">  for(int i=0;i&lt;s.size();i++)&#123;</span><br><span class="line">  if(s[i]==&#x27;&#123;&#x27;)l++;</span><br><span class="line">  else&#123;</span><br><span class="line">  if(l)l--;//能出就出队 </span><br><span class="line">  else&#123;</span><br><span class="line">  num++;//操作一次 </span><br><span class="line">  l++;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;%d. %d\n&quot;,id++,num+l/2);//num是贪心操作下的次数，l是操作后的等效情况。 </span><br><span class="line">  &#125;</span><br><span class="line">  return 0; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;前言：&lt;/strong&gt;这篇博客主要关于c++STL中的一些容器，堆(heap)和栈(stack)，堆的特点是先进先出，priority_queue以及queue都是相关的关键词。而栈的特点是先进后出，stack是相关关键词。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://onem.cloud/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="STL" scheme="http://onem.cloud/tags/STL/"/>
    
    <category term="堆(queue)" scheme="http://onem.cloud/tags/%E5%A0%86-queue/"/>
    
    <category term="栈(stack)" scheme="http://onem.cloud/tags/%E6%A0%88-stack/"/>
    
  </entry>
  
  <entry>
    <title>树状数组专题</title>
    <link href="http://onem.cloud/2023/01/20/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%B8%93%E9%A2%98/"/>
    <id>http://onem.cloud/2023/01/20/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%B8%93%E9%A2%98/</id>
    <published>2023-01-20T12:16:36.412Z</published>
    <updated>2023-01-21T02:46:54.722Z</updated>
    
    <content type="html"><![CDATA[<h4 id="模板："><a href="#模板：" class="headerlink" title="模板："></a>模板：</h4><p>​首先我们先看看树状数组的<a href="https://baike.baidu.com/item/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/313739?fr=aladdin">相关介绍</a>，在我们遇到的题目中，我们可以看到大致一下三类可以用树状数组的类型：1.单点修改+区间查询和（主要） 2.区间修改+单点查询和 3.区间修改+区间查询 4.单点修改+区间查询最大&#x2F;小值</p><p>首先我们先看看树状数组的主要模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span><span class="comment">//单点修改+区间查询</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>;</span><br><span class="line"><span class="type">int</span> n;<span class="comment">//数组长度</span></span><br><span class="line"><span class="type">int</span> raw_array[N];<span class="comment">//原数组（下标从1开始）</span></span><br><span class="line"><span class="type">int</span> BinaryIndexedtree[N];<span class="comment">//根据原数组构建的树状数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> k&amp;-k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> val)</span></span>&#123;<span class="comment">//假设需要在下标id处加val</span></span><br><span class="line"> <span class="keyword">while</span>(id&lt;=n)&#123;</span><br><span class="line">        BinaryIndexedtree[id]+=val;</span><br><span class="line">        id+=<span class="built_in">lowbit</span>(id);<span class="comment">//将所有包括raw_array[id]的树状数组的项进行修改</span></span><br><span class="line">    &#125;   <span class="comment">//这里是树状数组的一个优点，在单点修改，区间查询下，如果用前缀和维护，修改前缀和时将是O(N)基本的操作，但是在树状数组的特殊构造下，只需进行O(logN)基本的修改。大大优化时间复杂度。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;<span class="comment">//初始化树状数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">       <span class="built_in">update</span>(i,raw_array[i]); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;<span class="comment">//查询原数组前id项之和</span></span><br><span class="line">    <span class="type">int</span> remain=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(id&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        remain+=BinaryIndexedtree[id];<span class="comment">//这一步就如同拼图一样，将所有包含原数组的树状数组拼在一起。</span></span><br><span class="line">        id-=<span class="built_in">lowbit</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> remain;</span><br><span class="line">&#125; <span class="comment">//若我们求raw_array数组的[l,r]的区间和，只需query(r)-query(l-1)即可求出</span></span><br></pre></td></tr></table></figure><h4 id="例题1：单点查询-区间查询-洛谷P3374树状数组1"><a href="#例题1：单点查询-区间查询-洛谷P3374树状数组1" class="headerlink" title="例题1：单点查询+区间查询 洛谷P3374树状数组1"></a>例题1：<a href="https://www.luogu.com.cn/problem/P3374">单点查询+区间查询 洛谷P3374树状数组1</a></h4><p>由题易知这道题考察的是<strong>单点查询+区间查询和</strong></p><h5 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span><span class="comment">//单点修改+区间查询</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> arr1[<span class="number">500003</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> c[<span class="number">500003</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> val)</span></span>&#123;<span class="comment">//代表第id个点增加val个单位 ，更新树状数组 </span></span><br><span class="line"><span class="keyword">while</span>(id&lt;=n)&#123;</span><br><span class="line">c[id]+=val;</span><br><span class="line">id+=<span class="built_in">lowbit</span>(id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;<span class="comment">//代表前id个单位之和 </span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> remain=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(id&gt;<span class="number">0</span>)&#123;</span><br><span class="line">remain+=c[id];</span><br><span class="line">id-=<span class="built_in">lowbit</span>(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> remain;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;arr1[i]);</span><br><span class="line"><span class="built_in">update</span>(i,arr1[i]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">int</span> num=<span class="number">0</span>,x=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;num,&amp;x,&amp;k);</span><br><span class="line"><span class="keyword">if</span>(num==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">update</span>(x,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>,<span class="built_in">sum</span>(k)-<span class="built_in">sum</span>(x<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="例题2：区间修改-单点查询-洛谷P3368树状数组2"><a href="#例题2：区间修改-单点查询-洛谷P3368树状数组2" class="headerlink" title="例题2：区间修改+单点查询 洛谷P3368树状数组2"></a>例题2：<a href="https://www.luogu.com.cn/problem/P3368">区间修改+单点查询 洛谷P3368树状数组2</a></h4><p>易知这道题考察的是<strong>区间修改+单点查询</strong>，但是我们所熟悉的是<strong>单点查询+区间查询</strong>，如果单纯用循环套用单点修改来实现区间修改，这就会变成O(MlogN),显然不是最优的选择，我们不妨回归本心，树状数组的优点是可以快速求区间和，以及快速单点修改，那么我们是否可以对原数组进行处理，使得它的区间修改变成单点修改（或者有限且有规律的点修改），这里不妨介绍差分的思路，比如有一个数列arr是{4，3，5，8}我们把它转换为差分化数组arr1就是{4，-1，2，3}，这里有<br>$$<br>arr[i]&#x3D; \sum_{j&#x3D;1}^{i}{arr1[j]}<br>$$<br>这里不得不介绍差分数组的一个特性，即<strong>区间同加某一个值的时候只需在左端点加上这个值，在右端点后一个点减去这个值，即实现了区间修改</strong>。</p><p>我们差分化处理的目的是在区间修改的时候事实上变成了两个端点的单点修改，而利用数组树状的区间求和即实现的单点查询</p><h5 id="源码：-1"><a href="#源码：-1" class="headerlink" title="源码："></a>源码：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;//区间修改+单点查询</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=500003;</span><br><span class="line">int n,m;</span><br><span class="line">int arr[maxn],c[maxn];</span><br><span class="line">int lowbit(int x)&#123;</span><br><span class="line">return x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line">void update(int id,int val)&#123;</span><br><span class="line">while(id&lt;=n)&#123;</span><br><span class="line">c[id]+=val;</span><br><span class="line">id+=lowbit(id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int sum(int id)&#123;</span><br><span class="line">int remain=0;</span><br><span class="line">while(id&gt;0)&#123;</span><br><span class="line">remain+=c[id];</span><br><span class="line">id-=lowbit(id);</span><br><span class="line">&#125; </span><br><span class="line">return remain;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">int remain1=0;</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">int remain=0;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;remain);</span><br><span class="line">if(i==1)&#123;</span><br><span class="line">arr[i]=remain;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">arr[i]=remain-remain1;//先对原数组进行差分处理 </span><br><span class="line">&#125;//差分处理可以让区间修改转化为单点修改，单点查询转换为区间查询。 </span><br><span class="line">remain1=remain;</span><br><span class="line">update(i,arr[i]);//生成树状数组 </span><br><span class="line">&#125;</span><br><span class="line">/*for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">printf(&quot;%d &quot;,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);*/</span><br><span class="line">while(m--)&#123;</span><br><span class="line">int idx=0;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;idx);</span><br><span class="line">if(idx==1)&#123;</span><br><span class="line">int x=0,y=0,k=0;</span><br><span class="line">scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;k);</span><br><span class="line">update(x,k);</span><br><span class="line">if(y+1&lt;=n)update(y+1,-k);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">int id=0;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;id);</span><br><span class="line">printf(&quot;%d\n&quot;,sum(id));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="例题3-区间修改-区间查询"><a href="#例题3-区间修改-区间查询" class="headerlink" title="例题3:区间修改+区间查询"></a>例题3:区间修改+区间查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Problem Description</span><br><span class="line">张煊的金箍棒升级了！</span><br><span class="line"></span><br><span class="line">升级后的金箍棒是由N段相同长度的金属棒连接而成（最开始每段金属棒的价值都是1，从1到N编号）；</span><br><span class="line"></span><br><span class="line">张煊作为金箍棒的主人，可以对金箍棒任意一段施展魔法操作，每次操作就是将一段连续的金属棒（从X到Y编号）每一段都增加价值Z（Z为1,2,3三种）。</span><br><span class="line"></span><br><span class="line">现在，张煊想知道执行M次操作后某一段金箍棒总值。</span><br><span class="line"></span><br><span class="line">有Q次查询，每次询问一段（A到B）金箍棒的价值和。</span><br><span class="line"></span><br><span class="line">Input</span><br><span class="line">输入的第一行是测试数据的组数（不超过10个）。</span><br><span class="line"></span><br><span class="line">对于每组测试数据，第一行包含一个整数N（1 &lt;= N &lt;= 100000），表示金箍棒有N节组成，第二行包含两个整数M（0 &lt;= M &lt;= 100,000）和 Q（1 &lt;= Q &lt;= 100），分别表示执行M次魔法操作，有Q次查询。</span><br><span class="line"></span><br><span class="line">接下来的M行，每行包含三个整数X，Y，Z（1 &lt;= X &lt;= Y &lt;= N，1 &lt;= Z &lt;= 3），它定义了一个操作：将从X到Y编号的金属棒每一段的价值增加Z，其中 Z = 1或者 Z = 2 或者 Z = 3。</span><br><span class="line"></span><br><span class="line">接下来的Q行，每行包含二个整数A和B（1 &lt;= A &lt;= B &lt;= N），表示查询从A到B这一段金箍棒的价值总和。</span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line">对于每组测试数据，请输出Q行，每行一个数字，表示一次查询的结果。</span><br><span class="line">输入样例</span><br><span class="line">1</span><br><span class="line">10</span><br><span class="line">2 2</span><br><span class="line">1 5 2</span><br><span class="line">5 9 3</span><br><span class="line">1 4</span><br><span class="line">3 6</span><br><span class="line"> </span><br><span class="line">输出样例</span><br><span class="line">12</span><br><span class="line">16</span><br></pre></td></tr></table></figure><p>由例题二的区间修改+单点查询，我们知道了差分化这个操作，可以将区间修改转化为单点修改。但是如果我们区间查询呢？线段树当然可以完美解决，但是如果我们还是继续使用树状数组呢，树状数组的空间占用大小略优于线段树，可能可以在极限环境帮助我们ac题。</p><p>于是我们考虑继续将原数组差分化，先将区间修改优化为单点修改，然后我们开始考虑如何将差分数组的区间求和优化成正常区间求和。我们设普通数组为a[N]，差分数组为d[N]有<br>$$<br>a[i]&#x3D; \sum_{j&#x3D;1}^i{d[j]}<br>$$<br>接着a数组p位置之前的前缀和为<br>$$<br>\sum_{i&#x3D;1}^p{a[i]}&#x3D;\sum_{i&#x3D;1}^p\sum_{j&#x3D;1}^i{d[j]}&#x3D;\sum_{i&#x3D;1}^p{(d[i]*(p-i+1))}&#x3D;(p+1)*\sum_{i&#x3D;1}^p{d[i]}-\sum_{i&#x3D;1}^p{(d[i]*i)}<br>$$<br>由上溯公式推导结果可知，我们a数组的前缀和可以通过维护两个树状数组c1，c2来实现区间查询转化为单点查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c1[i]的原数组为d[i];</span><br><span class="line">c2[i]的原数组为d[i]*i;</span><br></pre></td></tr></table></figure><h5 id="源码：-2"><a href="#源码：-2" class="headerlink" title="源码："></a>源码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> t=<span class="number">0</span>,n=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> c1[N],d[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> c2[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> k&amp;-k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> id1=id;</span><br><span class="line"><span class="keyword">while</span>(id&lt;=n)&#123;</span><br><span class="line">c1[id]+=val;</span><br><span class="line">c2[id]+=id1*val;<span class="comment">//注意这个有可能会longlong </span></span><br><span class="line">id+=<span class="built_in">lowbit</span>(id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;<span class="comment">//前id段之和 </span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>,id1=id;</span><br><span class="line"><span class="keyword">while</span>(id&gt;<span class="number">0</span>)&#123;</span><br><span class="line">ans=ans+(id1+<span class="number">1</span>)*c1[id]-c2[id];</span><br><span class="line">id-=<span class="built_in">lowbit</span>(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">d[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> m,q;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;q);</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="type">int</span> x1,y1,z1;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;z1);</span><br><span class="line">d[x1]+=z1;</span><br><span class="line">d[y1+<span class="number">1</span>]-=z1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">update</span>(i,d[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line"><span class="type">int</span> x1,y1;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x1,&amp;y1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">sum</span>(y1)-<span class="built_in">sum</span>(x1<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(c1,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line"><span class="built_in">memset</span>(c2,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>)*(n+<span class="number">1</span>));</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*(n+<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例题4：单点修改-区间求最大值"><a href="#例题4：单点修改-区间求最大值" class="headerlink" title="例题4：单点修改+区间求最大值"></a><del>例题4：单点修改+区间求最大值</del></h4><p>如果有一个数列，其中我们有以下两个操作：1.将第i个数修改为k。2.查询[L,R]中的最大值。</p><p>你会如何写，我知道你下意识是用线段树，我们仍然ban掉线段树，<del>这不能让你们轻轻松松秒了，显得我很没面子啊www</del>，我们仅使用树状数组，突破常规思维的局限，你会如何完成呢？</p><p>首先我们要思考，此时树状数组相当于原函数的意义是什么，一般的树状数组是帮助我们简化修改的次数，以及求和的次数，这里的树状数组却要和最值扯上关系，我们不妨大胆尝试将原来树状数组代表的[id-lowbit(id)+1,id]区间之和重新定义为此区间的最大值，然后每次update树状数组的时候我们先在原数组处直接修改后，再在update的过程中对所有区间包含该点的树状数组和该修改后的值进行一次比较大小</p><h5 id="源码：-3"><a href="#源码：-3" class="headerlink" title="源码："></a>源码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树状数组求区间最大值</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>;</span><br><span class="line"><span class="type">int</span> a[N],h[N];<span class="comment">//h[x]储存的是[x-lowbit(x)+1,x]中每个数的最大值；</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//无论是初始输入，还是后面的单点更新，我们只需要在原数组直接修改，然后update即可。 </span></span><br><span class="line"><span class="type">int</span> lx=x;</span><br><span class="line"><span class="keyword">while</span>(x&lt;=n)&#123;</span><br><span class="line">h[x]=<span class="built_in">max</span>(h[x],a[lx]);<span class="comment">//在所有包含a[lx]的树状数组中查找看是否需要更新 </span></span><br><span class="line">x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="comment">//查询区间x到y的最大值 </span></span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(y&gt;=x)&#123;</span><br><span class="line">ans=<span class="built_in">max</span>(a[y],ans);</span><br><span class="line">y--;</span><br><span class="line"><span class="keyword">for</span>(;y-<span class="built_in">lowbit</span>(y)&gt;=x;y-=<span class="built_in">lowbit</span>(y))&#123;</span><br><span class="line">ans=<span class="built_in">max</span>(h[y],ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>P.S：（其实这个代码有点小问题，就是没考虑我们将一个区间最大值改小的情况qwq，可能需要特判一下，<del>所以大家还是用线段树处理求区间最大值问题吧</del>）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;：树状数组，作为求伴有单点修改过程中的区间和的利器，现在多用于技术数组的前缀和以及区间和，虽然线段树可以完美代替树状数组的功能，但是在部分场景下，有可能树状数组存在巧解，下面我将介绍数组树状的模板以及几种不同场景的应用。&lt;/p&gt;</summary>
    
    
    
    <category term="Luogu" scheme="http://onem.cloud/categories/Luogu/"/>
    
    <category term="题解" scheme="http://onem.cloud/categories/Luogu/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="树状数组" scheme="http://onem.cloud/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
    <category term="差分" scheme="http://onem.cloud/tags/%E5%B7%AE%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>矩阵快速幂专题</title>
    <link href="http://onem.cloud/2023/01/15/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E4%B8%93%E9%A2%98/"/>
    <id>http://onem.cloud/2023/01/15/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E4%B8%93%E9%A2%98/</id>
    <published>2023-01-15T08:32:09.000Z</published>
    <updated>2023-01-19T15:45:01.487Z</updated>
    
    <content type="html"><![CDATA[<h4 id="例题1："><a href="#例题1：" class="headerlink" title="例题1："></a>例题1：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Problem Description</span><br><span class="line">A为一个方阵，则Tr A表示A的迹（就是主对角线上各项的和），现要求Tr(A^k)%9973。</span><br><span class="line"></span><br><span class="line">Input</span><br><span class="line">数据的第一行是一个T，表示有T组数据。</span><br><span class="line">每组数据的第一行有n(2 &lt;= n &lt;= 10)和k(2 &lt;= k &lt; 10^9)两个数据。接下来有n行，每行有n个数据，每个数据的范围是[0,9]，表示方阵A的内容。</span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line">对应每组数据，输出Tr(A^k)%9973。</span><br><span class="line"></span><br><span class="line">输入样例</span><br><span class="line">2</span><br><span class="line">2 2</span><br><span class="line">1 0</span><br><span class="line">0 1</span><br><span class="line">3 99999999</span><br><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br><span class="line">输出样例</span><br><span class="line">2</span><br><span class="line">2686</span><br></pre></td></tr></table></figure><h5 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">9973</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">long</span> <span class="type">long</span> (*a1)[<span class="number">11</span>],<span class="type">long</span> <span class="type">long</span> (*a2)[<span class="number">11</span>],<span class="type">int</span> k)</span></span>&#123;<span class="comment">//矩阵乘法  k为矩阵的阶数 </span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> remain[<span class="number">11</span>][<span class="number">11</span>]=&#123;<span class="number">0</span>&#125; ;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> z=<span class="number">1</span>;z&lt;=k;z++)&#123;</span><br><span class="line">remain[i][j]+=(a1[i][z]*a2[z][j])%mod;<span class="comment">//矩阵乘法的核心</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line">a1[i][j]=remain[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_mi</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> len)</span></span>&#123;<span class="comment">//k为幂，len为阶 </span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> remain[<span class="number">11</span>][<span class="number">11</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">remain[i][i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(k)&#123;<span class="comment">//和一般快速幂一样</span></span><br><span class="line"><span class="keyword">if</span>(k&amp;<span class="number">1</span>)<span class="built_in">mul</span>(remain,a,len);</span><br><span class="line"><span class="built_in">mul</span>(a,a,len);</span><br><span class="line">k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=len;j++)&#123;</span><br><span class="line">a[i][j]=remain[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="type">int</span> n,k,ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">quick_mi</span>(k,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">ans+=a[i][i];</span><br><span class="line"><span class="keyword">if</span>(ans&gt;=mod)&#123;</span><br><span class="line">ans%=mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​这道题还比较基础，仅仅考验了矩阵运算和快速幂的部分，核心的将题目递推公式推出然后矩阵乘法化还没有考察到，但接下来的第二题便有所体现了。</p><h4 id="例题2："><a href="#例题2：" class="headerlink" title="例题2："></a>例题2：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Problem Description</span><br><span class="line">Everybody knows Fibonacci numbers, now we are talking about the Tribonacci numbers:</span><br><span class="line">T[0] = T[1] = T[2] = 1;</span><br><span class="line">T[n] = T[n - 1] + T[n - 2] + T[n - 3] (n &gt;= 3)</span><br><span class="line"></span><br><span class="line">Given a and b, you are asked to calculate the sum from the ath Fibonacci number to the bth Fibonacci number, mod 1,000,000,007, that is (T[a] + T[a + 1] + … + T[b]) % 1,000,000,007.</span><br><span class="line"></span><br><span class="line">Input</span><br><span class="line">There are multiple cases (no more than 100).</span><br><span class="line"></span><br><span class="line">Each case contain two non-negative integers a b(a &lt;= b and a, b &lt; 1,000,000,000)</span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line">For each case, output the sum % 1,000,000,007.</span><br><span class="line"></span><br><span class="line">输入样例</span><br><span class="line">0 2</span><br><span class="line">0 5</span><br><span class="line">输出样例</span><br><span class="line">3</span><br><span class="line">20</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>题目大意是我们现在重新定义一个数列规律，求第a项到第b项之和。</p><h5 id="源码：-1"><a href="#源码：-1" class="headerlink" title="源码："></a>源码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> b[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;<span class="comment">//这里是矩阵化的数组的初始状态</span></span><br><span class="line"><span class="type">int</span> a,b1;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_mat</span><span class="params">()</span></span>&#123;<span class="comment">//初始化矩阵乘法运算数组b</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">b[i][j]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(j==<span class="number">1</span>)&#123;</span><br><span class="line">b[i][j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">b[i][j]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(i<span class="number">-1</span>==j)&#123;</span><br><span class="line">b[i][j]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">b[i][j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">long</span> <span class="type">long</span> (*a)[<span class="number">5</span>],<span class="type">long</span> <span class="type">long</span> (*a1)[<span class="number">5</span>])</span></span>&#123;<span class="comment">//矩阵乘法</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> remain[<span class="number">5</span>][<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> z=<span class="number">1</span>;z&lt;=<span class="number">4</span>;z++)&#123;</span><br><span class="line">remain[i][j]=(remain[i][j]+a[i][z]*a1[z][j])%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++)&#123;</span><br><span class="line">a[i][j]=remain[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_mi</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;<span class="comment">//快速幂</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> remain[<span class="number">5</span>][<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line">remain[i][i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(k)&#123;</span><br><span class="line"><span class="keyword">if</span>(k&amp;<span class="number">1</span>)<span class="built_in">mul</span>(remain,b);</span><br><span class="line"><span class="built_in">mul</span>(b,b);</span><br><span class="line">k&gt;&gt;=<span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++)&#123;</span><br><span class="line">b[i][j]=remain[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k&lt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k&lt;<span class="number">3</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> k+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">quick_mi</span>(k<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line">ans+=b[<span class="number">1</span>][i]*f[i];</span><br><span class="line"><span class="keyword">if</span>(ans&gt;=mod)ans%=mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b1)==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">init_mat</span>();</span><br><span class="line"><span class="type">int</span> ans1=<span class="built_in">count</span>(a<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">init_mat</span>();</span><br><span class="line"><span class="type">int</span> ans2=<span class="built_in">count</span>(b1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(ans2-ans1+mod)%mod);<span class="comment">//ans2原值对mod的余数可能会小于ans1，所以要进行取余操作 易错点！！！ </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这道题虽然给出了我们到第几项的规律，但是需要求的是sum，所以我们还需要推出前缀和的原公式，然后再进行矩阵快速幂。</p><h4 id="例题3："><a href="#例题3：" class="headerlink" title="例题3："></a>例题3：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Problem Description</span><br><span class="line">As we all known , the Fibonacci series : F(0) = 1, F(1) = 1, F(N) = F(N - 1) + F(N - 2) (N &gt;= 2).Now we define another kind of Fibonacci : A(0) = 1 , A(1) = 1 , A(N) = X A(N - 1) + Y A(N - 2) (N &gt;= 2).And we want to Calculate S(N) , S(N) = A(0)^2 +A(1)^2+……+A(n)^2.</span><br><span class="line"></span><br><span class="line">Input</span><br><span class="line">There are several test cases.</span><br><span class="line">Each test case will contain three integers , N, X , Y .</span><br><span class="line">N : 2&lt;= N &lt;= 2^31 – 1</span><br><span class="line">X : 2&lt;= X &lt;= 2^31– 1</span><br><span class="line">Y : 2&lt;= Y &lt;= 2^31 – 1</span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line">For each test case , output the answer of S(n).If the answer is too big , divide it by 10007 and give me the reminder.</span><br><span class="line">输入样例</span><br><span class="line">2 1 1 </span><br><span class="line">3 2 3 </span><br><span class="line">输出样例</span><br><span class="line">6</span><br><span class="line">196</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="源码：-2"><a href="#源码：-2" class="headerlink" title="源码："></a>源码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">10007</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,x,y;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[<span class="number">4</span>]=&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> b[<span class="number">4</span>][<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_mat</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">b[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">b[i][<span class="number">1</span>]=x*x%mod;</span><br><span class="line">b[i][<span class="number">2</span>]=<span class="number">2</span>*x*y%mod;</span><br><span class="line">b[i][<span class="number">3</span>]=y*y%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">b[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">b[i][<span class="number">1</span>]=x*x%mod;</span><br><span class="line">b[i][<span class="number">2</span>]=<span class="number">2</span>*x*y%mod;<span class="comment">//防止longlong溢出  原因是longlong的最大值是20左右，x，y最大值为1&lt;&lt;31-1 如果 2xy*2xy容易向上溢出 .</span></span><br><span class="line">b[i][<span class="number">3</span>]=y*y%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">b[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">b[i][<span class="number">1</span>]=x;</span><br><span class="line">b[i][<span class="number">2</span>]=y;</span><br><span class="line">b[i][<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">b[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">b[i][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">b[i][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">b[i][<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">long</span> <span class="type">long</span> (*a)[<span class="number">4</span>],<span class="type">long</span> <span class="type">long</span> (*a1)[<span class="number">4</span>])</span></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> remain[<span class="number">4</span>][<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> z=<span class="number">0</span>;z&lt;<span class="number">4</span>;z++)&#123;</span><br><span class="line">remain[i][j]=(remain[i][j]+a[i][z]*a1[z][j])%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">a[i][j]=remain[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_mi</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> remain[<span class="number">4</span>][<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">remain[i][i]=<span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">while</span>(k)&#123;</span><br><span class="line"><span class="keyword">if</span>(k&amp;<span class="number">1</span>)<span class="built_in">mul</span>(remain,b);</span><br><span class="line"><span class="built_in">mul</span>(b,b);</span><br><span class="line">k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">b[i][j]=remain[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;n,&amp;x,&amp;y)==<span class="number">3</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;=mod)&#123;</span><br><span class="line">x%=mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(y&gt;=mod)&#123;</span><br><span class="line">y%=mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">&quot;2\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">init_mat</span>();</span><br><span class="line"><span class="built_in">quick_mi</span>(n<span class="number">-1</span>);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">ans+=f[i]*b[<span class="number">0</span>][i];</span><br><span class="line"><span class="keyword">if</span>(ans&gt;=mod)ans%=mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这篇博客仅仅还是一篇草稿，温故而知新，还需要后期的复习后的感想，才算发挥出来这篇博客应有的作用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;：这篇博客是有关矩阵快速幂的相关例题和模板，矩阵快速幂深刻地体现了基础数学对于算法优化的重要性，矩阵快速幂是先将题目的递推公式矩阵乘法化，然后通过将快速幂和矩阵乘法结合，利用快速幂优化多次矩阵乘法中重复的部分，将运算部分的时间复杂度从O(N)优化到O(log N)，从而实现优化。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://onem.cloud/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="快速幂" scheme="http://onem.cloud/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
    <category term="矩阵快速幂" scheme="http://onem.cloud/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
    <category term="数学" scheme="http://onem.cloud/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>线段树专题</title>
    <link href="http://onem.cloud/2023/01/11/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%93%E9%A2%98/"/>
    <id>http://onem.cloud/2023/01/11/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%93%E9%A2%98/</id>
    <published>2023-01-11T03:12:57.000Z</published>
    <updated>2023-01-21T11:35:33.877Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们先来介绍线段树的基本组成部分，有原数组arr[N]，线段树数组segtree[N]，线段树每个元素包括当前节点的权重（原数组在某一区间的区间和等等）。</p><h4 id="模板：单点修改-区间查询"><a href="#模板：单点修改-区间查询" class="headerlink" title="模板：单点修改+区间查询"></a>模板：单点修改+区间查询</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线段树的单点修改，区间求和</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">8</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Segtreemode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;segtree[N&lt;&lt;<span class="number">2</span>];<span class="comment">//这里4*n是保证 可以将完全平衡二叉树化的原数组完美存入。</span></span><br><span class="line"><span class="type">int</span> arr[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;<span class="comment">//合并操作，其中rt&lt;&lt;1和rt&lt;&lt;1|1分别是根节点为rt的左右子树节点</span></span><br><span class="line">    segtree[rt]=segtree[rt&lt;&lt;<span class="number">1</span>].val+segtree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span></span>&#123;<span class="comment">//构建线段树 l是当前的原数组左区间下标，r是当前原数组右区间下标 rt是当前线段树的节点下标</span></span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;<span class="comment">//如果到了叶节点，直接赋值</span></span><br><span class="line">        segtree[rt].val=arr[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">build</span>(l,mid,rt&lt;&lt;<span class="number">1</span>);<span class="comment">//构建当前左子树</span></span><br><span class="line">        <span class="built_in">build</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);<span class="comment">//构建当前右子树</span></span><br><span class="line">        <span class="built_in">pushup</span>(rt);<span class="comment">//合并左右子树的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> val,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span></span>&#123;<span class="comment">//单点修改 将原数组下标为id的位置增加val，当然访问的原数组区间是[l,r]，在线段树里的节点是rt</span></span><br><span class="line">    <span class="keyword">if</span>(l==r&amp;&amp;r==id)&#123;</span><br><span class="line">        segtree[rt].val+=val;</span><br><span class="line">      <span class="comment">//segtree[rt].val=val;//如果是将下标为id的值修改为val</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(id&lt;=mid)<span class="built_in">build</span>(id,val,l,mid,rt&lt;&lt;<span class="number">1</span>);<span class="comment">//经典二分查找的步骤</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">build</span>(id,val,mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushup</span>(rt);<span class="comment">//保证子树更新后，上面的根节点也会跟着更新</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span></span>&#123;<span class="comment">//区间查询，需要查询的是区间[L,R],当前区间是[l,r],对应线段树节点是rt</span></span><br><span class="line"><span class="type">int</span> remain=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;<span class="comment">//如果当前区间正好被需要查询的区间包含。</span></span><br><span class="line">        <span class="keyword">return</span> segtree[rt].val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(r&lt;L||l&gt;R)&#123;<span class="comment">//如果完全不相交</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//区间存在交叉</span></span><br><span class="line">        <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(L,R,l,mid,rt&lt;&lt;<span class="number">1</span>)+<span class="built_in">query</span>(L,R,mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​大致来看，你会发现树状数组和线段树的优化原理很相似，都是通过将原数组按规律割分成若干子区间，从而减少对某个点修改甚至对某个区间修改时的对预处理数组的修改次数，但是线段树和树状数组有个本质上的区别，树状数组的底层原理只能支持它代表整体区间，对于如果想来表示区间中的一个最大值，则会在修改的过程的中，如果不借助其他辅助数组就会不确定这个特征值是否会改变，而线段树，就不会有这个问题，所以这就是在处理查询区间最大值时，线段树是第一选择。</p><p>​然而线段树的精髓真的体现却是在<strong>区间修改+区间查询</strong>。其中需要用到lazy标记，<del>充分体现了节能主义，</del>，其绝不干除了影响查询结果之外其他多余的事，但是对于那些相对于查询多余的修改，虽然没做，但是会做上标记，如果查询到了它的头上，我才进行修改。</p><h4 id="例题2：洛谷P3373线段树1区间修改-区间查询"><a href="#例题2：洛谷P3373线段树1区间修改-区间查询" class="headerlink" title="例题2：洛谷P3373线段树1区间修改+区间查询"></a>例题2：<a href="https://www.luogu.com.cn/problem/P3372">洛谷P3373线段树1</a>区间修改+区间查询</h4><p>由题易知我们需要进行将一个区间全部加上一个值，或者求一个区间和的操作，我们先仔细看看这道题的数据范围<br>$$<br>1\leq{n,m}\leq10^5<br>$$<br>其中n是原数组个数，m是操作次数，我们不妨取一个极限，n和m均为10^5,若我们进行10^5 -1次从（1+random（1<del>100））到（10^5-random（1</del>100））每个数字增加一个random（1~100）；</p><p>最后查询一个[L,R]的区间和，如果我们每次区间修改操作都老老实实地直到每个子树都修改完才进行下次操作，我们易算出此时的极限操作单点操作次数一定有一个n*m，10^10毫无疑问超时了，我们手动在草稿纸上模拟的时候容易发现，在很多时候没必要细化修改到子树，我们在包含这些子树的根节点上标记一下，等区间查询查到它的头上的时候再把标记下放下去即可。</p><h5 id="源码：线段树-lazy操作"><a href="#源码：线段树-lazy操作" class="headerlink" title="源码：线段树+lazy操作"></a>源码：线段树+lazy操作</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线段树 区间更新+区间查询 （懒标记） </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>; </span><br><span class="line"><span class="type">int</span> n,m;<span class="comment">//n是数组长度，m是操作次数</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[N];<span class="comment">//原数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTreeNode</span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> val;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> lazy;<span class="comment">//懒标记的精髓在于，不把工作做全了（会在没完整的任务前一个根节点做标记），但是不影响大整体 ，只有下次再做统计工作，没完成的部分会影响结果的时候，以及查询具体完全情况的时候 我才完成之前没有完成的工作 </span></span><br><span class="line">&#125;SegTree[N&lt;&lt;<span class="number">2</span>];<span class="comment">//线段树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PushUp</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;<span class="comment">//合并左右子树 </span></span><br><span class="line">SegTree[rt].val=SegTree[rt&lt;&lt;<span class="number">1</span>].val+SegTree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PushDown</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="comment">//将懒标记下推至左右子树 </span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> mid=(l+r)/<span class="number">2</span>,remain=SegTree[rt].lazy;</span><br><span class="line">SegTree[rt&lt;&lt;<span class="number">1</span>].lazy+=remain;<span class="comment">//左子树继承lazy标签，重点在于操作符是+=！！</span></span><br><span class="line">SegTree[rt&lt;&lt;<span class="number">1</span>].val+=(mid-l+<span class="number">1</span>)*remain;<span class="comment">//更新左子树val值</span></span><br><span class="line">SegTree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lazy+=remain;<span class="comment">//右子树继承lazy标签</span></span><br><span class="line">SegTree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val+=(r-mid)*remain;<span class="comment">//更新右子树val值</span></span><br><span class="line">SegTree[rt].lazy=<span class="number">0</span>;<span class="comment">//归零根节点lazy标签</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span></span>&#123;<span class="comment">//建线段树 </span></span><br><span class="line">SegTree[rt].lazy=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">SegTree[rt].val=a[l];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">build</span>(l,mid,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line"><span class="built_in">build</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line"><span class="built_in">PushUp</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> C,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span></span>&#123;<span class="comment">//[L,R]区间每个点加上C，当前区间[l,r],rt; </span></span><br><span class="line"><span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">SegTree[rt].val+=(r-l+<span class="number">1</span>)*C;</span><br><span class="line">SegTree[rt].lazy+=C;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(r&lt;L||l&gt;R)&#123;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(SegTree[rt].lazy!=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">PushDown</span>(rt,l,r);<span class="comment">//！！注意在存在交叉区间的更新过程中，遇到lazy标签必须要向下推，因为如果不向下推，而绕过它去它的子树标记新的lazy，则在之后的pushup过程中，前一个lazy标签伴随的“SegTree[rt].val+=(r-l+1)*C;”会被子树合并时覆盖而消除，从而引起错误。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">update</span>(L,R,C,l,mid,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line"><span class="built_in">update</span>(L,R,C,mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line"><span class="built_in">PushUp</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span>  <span class="title">Query</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span></span>&#123;<span class="comment">//我们要询问的是从L到R,当前区间是[l,r]; </span></span><br><span class="line"><span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R )&#123;<span class="comment">//如果当前区间被需要查询的区间包含 </span></span><br><span class="line"><span class="keyword">return</span> SegTree[rt].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(r&lt;L||l&gt;R)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//存在交叉区间 </span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(SegTree[rt].lazy!=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">PushDown</span>(rt,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*long long ans=0;</span></span><br><span class="line"><span class="comment">if(L&lt;=mid)ans+=Query(L,R,l,mid,rt&lt;&lt;1);//需要查询的区间与当前区间的左子树有重合 </span></span><br><span class="line"><span class="comment">if(mid&lt;R) ans+=Query(L,R,mid+1,r,rt&lt;&lt;1|1); </span></span><br><span class="line"><span class="comment">return ans;*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Query</span>(L,R,l,mid,rt&lt;&lt;<span class="number">1</span>)+<span class="built_in">Query</span>(L,R,mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="type">int</span> id=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;id);</span><br><span class="line"><span class="keyword">if</span>(id==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> x1,y1,k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;x1,&amp;y1,&amp;k);</span><br><span class="line"><span class="built_in">update</span>(x1,y1,k,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> x1,y1;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x1,&amp;y1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">Query</span>(x1,y1,<span class="number">1</span>,n,<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例题3：线段树-区间合并"><a href="#例题3：线段树-区间合并" class="headerlink" title="例题3：线段树+区间合并"></a>例题3：线段树+区间合并</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Problem Description</span><br><span class="line">Given n integers.</span><br><span class="line">You have two operations:</span><br><span class="line">U A B: replace the Ath number by B. (index counting from 0)</span><br><span class="line">Q A B: output the length of the longest consecutive increasing subsequence (LCIS) in [a, b].</span><br><span class="line"></span><br><span class="line">Input</span><br><span class="line">T in the first line, indicating the case number.</span><br><span class="line">Each case starts with two integers n , m(0&lt;n,m&lt;=10^5).</span><br><span class="line">The next line has n integers(0&lt;=val&lt;=10^5).</span><br><span class="line">The next m lines each has an operation:</span><br><span class="line">U A B(0&lt;=A,n , 0&lt;=B=10^5)</span><br><span class="line">OR</span><br><span class="line">Q A B(0&lt;=A&lt;=B&lt; n).</span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line">For each Q, output the answer.</span><br><span class="line"></span><br><span class="line">输入样例</span><br><span class="line">1</span><br><span class="line">10 10</span><br><span class="line">7 7 3 3 5 9 9 8 1 8 </span><br><span class="line">Q 6 6</span><br><span class="line">U 3 4</span><br><span class="line">Q 0 1</span><br><span class="line">Q 0 5</span><br><span class="line">Q 4 7</span><br><span class="line">Q 3 5</span><br><span class="line">Q 0 2</span><br><span class="line">Q 4 6</span><br><span class="line">U 6 10</span><br><span class="line">Q 0 9</span><br><span class="line"> </span><br><span class="line">输出样例</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>LCIS:最长上升相邻子序列</strong></p><h5 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1e5+8;</span><br><span class="line">int a[N];</span><br><span class="line">struct Segtreemode&#123;</span><br><span class="line">int max1;</span><br><span class="line">int lmax;</span><br><span class="line">int rmax;</span><br><span class="line"></span><br><span class="line">&#125;segtree[N&lt;&lt;2];</span><br><span class="line">void pushup(int l,int r,int rt)&#123;</span><br><span class="line">int mid=(l+r)/2;</span><br><span class="line">if(a[mid]&gt;=a[mid+1])&#123;//区间不能合并 </span><br><span class="line">segtree[rt].max1=max(segtree[rt&lt;&lt;1].max1,segtree[rt&lt;&lt;1|1].max1);</span><br><span class="line">segtree[rt].lmax=segtree[rt&lt;&lt;1].lmax;</span><br><span class="line">segtree[rt].rmax=segtree[rt&lt;&lt;1|1].rmax;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;//可以合并 </span><br><span class="line">segtree[rt].max1=max(segtree[rt&lt;&lt;1].max1,max(segtree[rt&lt;&lt;1|1].max1,segtree[rt&lt;&lt;1].rmax+segtree[rt&lt;&lt;1|1].lmax));</span><br><span class="line">segtree[rt].lmax=segtree[rt&lt;&lt;1].lmax==(mid-l+1)?segtree[rt&lt;&lt;1].lmax+segtree[rt&lt;&lt;1|1].lmax:segtree[rt&lt;&lt;1].lmax;</span><br><span class="line">segtree[rt].rmax=segtree[rt&lt;&lt;1|1].rmax==(r-mid)?segtree[rt&lt;&lt;1|1].rmax+segtree[rt&lt;&lt;1].rmax:segtree[rt&lt;&lt;1|1].rmax;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void build(int l,int r,int rt)&#123;</span><br><span class="line">if(l==r)&#123;</span><br><span class="line">segtree[rt].max1=segtree[rt].lmax=segtree[rt].rmax=1;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">int mid=(l+r)/2;</span><br><span class="line">build(l,mid,rt&lt;&lt;1);</span><br><span class="line">build(mid+1,r,rt&lt;&lt;1|1);</span><br><span class="line">pushup(l,r,rt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void update(int id,int k,int l,int r,int rt)&#123;</span><br><span class="line">if(l==r&amp;&amp;r==id)&#123;</span><br><span class="line">a[id]=k;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">else if(r&lt;id||id&lt;l)&#123;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">int mid=(l+r)/2;</span><br><span class="line">update(id,k,l,mid,rt&lt;&lt;1);</span><br><span class="line">update(id,k,mid+1,r,rt&lt;&lt;1|1);</span><br><span class="line">pushup(l,r,rt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int query(int l1,int r1,int l,int r,int rt)&#123;</span><br><span class="line">if(l&gt;=l1&amp;&amp;r&lt;=r1)&#123;</span><br><span class="line">return segtree[rt].max1;</span><br><span class="line">&#125;</span><br><span class="line">else if(r&lt;l1||l&gt;r1)&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;//当当前区间和所需求的区间有重合的时候 </span><br><span class="line">int mid=(l+r)/2;</span><br><span class="line"></span><br><span class="line">int ans=0;</span><br><span class="line">int ans1=query(l1,r1,l,mid,rt&lt;&lt;1);</span><br><span class="line">int ans2=query(l1,r1,mid+1,r,rt&lt;&lt;1|1);</span><br><span class="line">ans=max(ans1,ans2);</span><br><span class="line">//if(l1&lt;=mid)ans=max(ans,query(l1,r1,l,mid,rt&lt;&lt;1));</span><br><span class="line">//if(r1&gt;mid)ans=max(ans,query(l1,r1,mid+1,r,rt&lt;&lt;1|1));</span><br><span class="line"></span><br><span class="line">if(a[mid]&lt;a[mid+1])&#123;</span><br><span class="line">ans=max(ans,min(mid-l1+1,segtree[rt&lt;&lt;1].rmax)+min(r1-mid,segtree[rt&lt;&lt;1|1].lmax));//重点！！！ </span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int t=0;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">while(t--)&#123;</span><br><span class="line">int n,m;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line">build(1,n,1);</span><br><span class="line"></span><br><span class="line">while(m--)&#123;</span><br><span class="line">char idx;</span><br><span class="line">int x1,y1;</span><br><span class="line"></span><br><span class="line">scanf(&quot; %c%d%d&quot;,&amp;idx,&amp;x1,&amp;y1);</span><br><span class="line">if(idx==&#x27;Q&#x27;)&#123;</span><br><span class="line">printf(&quot;%d\n&quot;,query(x1+1,y1+1,1,n,1));</span><br><span class="line">&#125; </span><br><span class="line">else&#123;</span><br><span class="line">update(x1+1,y1,1,n,1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="例题4：洛谷P3373线段树综合"><a href="#例题4：洛谷P3373线段树综合" class="headerlink" title="例题4：洛谷P3373线段树综合"></a>例题4：<a href="https://www.luogu.com.cn/problem/P3373">洛谷P3373线段树综合</a></h4><p>这道题稍微有点麻烦，就是处理乘法和加法的前后顺序上。</p><h5 id="源码：-1"><a href="#源码：-1" class="headerlink" title="源码："></a>源码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">8</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,m,p;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Segtreemode</span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> val;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> mul;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> add;</span><br><span class="line">&#125;segtree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">segtree[rt].val=(segtree[rt&lt;&lt;<span class="number">1</span>].val+segtree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val)%p; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span></span>&#123;<span class="comment">//优先乘法，之后加法  当前区间[l,r]，线段树下标rt </span></span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">segtree[rt&lt;&lt;<span class="number">1</span>].val=(segtree[rt&lt;&lt;<span class="number">1</span>].val*segtree[rt].mul+(mid-l+<span class="number">1</span>)*segtree[rt].add)%p;</span><br><span class="line">segtree[rt&lt;&lt;<span class="number">1</span>].mul=(segtree[rt].mul*segtree[rt&lt;&lt;<span class="number">1</span>].mul)%p;</span><br><span class="line">segtree[rt&lt;&lt;<span class="number">1</span>].add=(segtree[rt].add+segtree[rt].mul*segtree[rt&lt;&lt;<span class="number">1</span>].add)%p;<span class="comment">//注意乘法优先原则，如果在乘法之前存在加法，要把加法提出来 </span></span><br><span class="line">segtree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val=(segtree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val*segtree[rt].mul+(r-mid)*segtree[rt].add)%p;</span><br><span class="line">segtree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mul=(segtree[rt].mul*segtree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mul)%p;</span><br><span class="line">segtree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].add=(segtree[rt].add+segtree[rt].mul*segtree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].add)%p;<span class="comment">//同理 </span></span><br><span class="line">segtree[rt].mul=<span class="number">1</span>;</span><br><span class="line">segtree[rt].add=<span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span></span>&#123;<span class="comment">// 当前区间[l,r]，线段树下标rt</span></span><br><span class="line">segtree[rt].mul=<span class="number">1</span>;</span><br><span class="line">segtree[rt].add=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">segtree[rt].val=a[l]%p;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">build</span>(l,mid,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line"><span class="built_in">build</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line"><span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_mul</span><span class="params">(<span class="type">int</span> l1,<span class="type">int</span> r1,<span class="type">long</span> <span class="type">long</span> c,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span></span>&#123;<span class="comment">//需要操作的空间[l1,r1];</span></span><br><span class="line"> <span class="keyword">if</span>(l&gt;=l1&amp;&amp;r&lt;=r1)&#123;</span><br><span class="line"> segtree[rt].val =(segtree[rt].val*c)%p;</span><br><span class="line"> segtree[rt].mul=(segtree[rt].mul*c)%p;</span><br><span class="line"> segtree[rt].add=(segtree[rt].add*c)%p;</span><br><span class="line"> <span class="keyword">return</span> ;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;r1||r&lt;l1)<span class="keyword">return</span> ;</span><br><span class="line"> <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"> <span class="built_in">pushdown</span>(l,r,rt);</span><br><span class="line"> <span class="built_in">update_mul</span>(l1,r1,c,l,mid,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line"> <span class="built_in">update_mul</span>(l1,r1,c,mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line"> <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_add</span><span class="params">(<span class="type">int</span> l1,<span class="type">int</span> r1,<span class="type">long</span> <span class="type">long</span> c,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=l1&amp;&amp;r&lt;=r1)&#123;</span><br><span class="line">segtree[rt].val=(c*(r-l+<span class="number">1</span>)+segtree[rt].val)%p;</span><br><span class="line">segtree[rt].add=(segtree[rt].add+c)%p;<span class="comment">//关键 </span></span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(l&gt;r1||r&lt;l1)<span class="keyword">return</span> ;</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">pushdown</span>(l,r,rt);</span><br><span class="line"><span class="built_in">update_add</span>(l1,r1,c,l,mid,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line"><span class="built_in">update_add</span>(l1,r1,c,mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line"><span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l1,<span class="type">int</span> r1,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=l1&amp;&amp;r&lt;=r1)&#123;</span><br><span class="line"> <span class="keyword">return</span> segtree[rt].val;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;r1||r&lt;l1)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"> <span class="built_in">pushdown</span>(l,r,rt);</span><br><span class="line"> <span class="keyword">return</span> (<span class="built_in">query</span>(l1,r1,l,mid,rt&lt;&lt;<span class="number">1</span>)+<span class="built_in">query</span>(l1,r1,mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>))%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*freopen(&quot;C:\\Users\\yhl\\Downloads\\P3373_2.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">freopen(&quot;C:\\Users\\yhl\\Desktop\\p3373_2.out&quot;,&quot;w&quot;,stdout);*/</span> </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;n,&amp;m,&amp;p);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="type">int</span> id=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;id);</span><br><span class="line"><span class="keyword">if</span>(id==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> x,y,k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;x,&amp;y,&amp;k);</span><br><span class="line"><span class="built_in">update_mul</span>(x,y,k,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(id==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> x,y,k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;x,&amp;y,&amp;k);</span><br><span class="line"><span class="built_in">update_add</span>(x,y,k,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query</span>(x,y,<span class="number">1</span>,n,<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>​对于区间修改和查询等操作下，线段树是一选，如果题目对内存卡的特别死，我们再考虑它的下位树状数组。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;：在树状数组那一篇博客里活跃的一个名词，没错，就是树状数组的上位，线段树它来了，线段树通过二分的思想，将一个数列分成一个完全平衡二叉树，通过其的深度不超过log(N)来保证访问的时间优化性。&lt;/p&gt;</summary>
    
    
    
    <category term="Luogu" scheme="http://onem.cloud/categories/Luogu/"/>
    
    <category term="题解" scheme="http://onem.cloud/categories/Luogu/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="线段树" scheme="http://onem.cloud/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>z5亲身评测以及第一次扫街成果</title>
    <link href="http://onem.cloud/2022/10/27/my-first-blog-in-github/"/>
    <id>http://onem.cloud/2022/10/27/my-first-blog-in-github/</id>
    <published>2022-10-26T16:00:00.000Z</published>
    <updated>2022-11-21T13:00:26.528Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-z5第一次扫街成果-直出效果"><a href="#1-z5第一次扫街成果-直出效果" class="headerlink" title="1.z5第一次扫街成果(直出效果)"></a>1.z5第一次扫街成果(直出效果)</h3><h6 id="暗光下的表现"><a href="#暗光下的表现" class="headerlink" title="暗光下的表现"></a>暗光下的表现</h6><table><thead><tr><th><img src="/2022/10/27/my-first-blog-in-github/2022.11.5-1.JPG"></th></tr></thead><tbody><tr><td>快门优先  f&#x2F;6.3  1&#x2F;80s  ISO-51200 曝光补偿:0  焦距:50mm</td></tr></tbody></table><h6 id="局部暗与高光处的和谐过度，色彩宽容度高"><a href="#局部暗与高光处的和谐过度，色彩宽容度高" class="headerlink" title="局部暗与高光处的和谐过度，色彩宽容度高"></a>局部暗与高光处的和谐过度，色彩宽容度高</h6><table><thead><tr><th><img src="/2022/10/27/my-first-blog-in-github/2022.11.5-2.JPG"></th></tr></thead><tbody><tr><td>手动 f&#x2F;8 1&#x2F;250s ISO-200 曝光补偿:0 焦距:50mm</td></tr></tbody></table><h6 id="阳光下的局部暗处与亮处"><a href="#阳光下的局部暗处与亮处" class="headerlink" title="阳光下的局部暗处与亮处"></a>阳光下的局部暗处与亮处</h6><table><thead><tr><th><img src="/2022/10/27/my-first-blog-in-github/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%89%AB%E8%A1%97_2022.11.5-056.JPG"></th></tr></thead><tbody><tr><td>手动 f&#x2F;9 1&#x2F;320s ISO-200 曝光补偿:0 焦距:47mm</td></tr></tbody></table><h6 id="下图不知道为什么霓虹灯色散明显，但是整体效果还行"><a href="#下图不知道为什么霓虹灯色散明显，但是整体效果还行" class="headerlink" title="下图不知道为什么霓虹灯色散明显，但是整体效果还行"></a>下图不知道为什么霓虹灯色散明显，但是整体效果还行</h6><table><thead><tr><th><img src="/2022/10/27/my-first-blog-in-github/%E7%AC%AC%E4%B8%89%E6%AC%A1%E9%95%BF%E6%9B%9D%E5%85%89%E5%B0%9D%E8%AF%95+%E6%9C%88%E5%85%A8%E9%A3%9F%E5%BB%B6%E6%97%B6%E6%8B%8D%E6%91%84_2022.11.7-022.JPG"></th></tr></thead><tbody><tr><td>快门优先 f&#x2F;6 1.6s ISO-125 曝光补偿:0 焦距:44mm</td></tr></tbody></table><h6 id="以及拍星空的效果（光污染有点大，银河基本拍不出来）"><a href="#以及拍星空的效果（光污染有点大，银河基本拍不出来）" class="headerlink" title="以及拍星空的效果（光污染有点大，银河基本拍不出来）"></a>以及拍星空的效果（光污染有点大，银河基本拍不出来）</h6><table><thead><tr><th><img src="/2022/10/27/my-first-blog-in-github/%E7%AC%AC%E4%B8%89%E6%AC%A1%E9%95%BF%E6%9B%9D%E5%85%89%E5%B0%9D%E8%AF%95+%E6%9C%88%E5%85%A8%E9%A3%9F%E5%BB%B6%E6%97%B6%E6%8B%8D%E6%91%84_2022.11.7-012.JPG"></th></tr></thead><tbody><tr><td>手动 f&#x2F;4 30s ISO-100 曝光补偿:0 焦距:24mm</td></tr></tbody></table><h6 id="蓝天与树与屋檐"><a href="#蓝天与树与屋檐" class="headerlink" title="蓝天与树与屋檐"></a>蓝天与树与屋檐</h6><table><thead><tr><th><img src="/2022/10/27/my-first-blog-in-github/%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%89%AB%E8%A1%97_2022.11.12-017.JPG"></th></tr></thead><tbody><tr><td>手动 f&#x2F;20 1&#x2F;1600s ISO-2500 曝光补偿:0 焦距:50mm</td></tr></tbody></table><h6 id="虚化效果（有点过曝了）"><a href="#虚化效果（有点过曝了）" class="headerlink" title="虚化效果（有点过曝了）"></a>虚化效果（有点过曝了）</h6><table><thead><tr><th><img src="/2022/10/27/my-first-blog-in-github/%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%89%AB%E8%A1%97_2022.11.12-029.JPG"></th></tr></thead><tbody><tr><td>手动 f&#x2F;8 1&#x2F;400s ISO-2500 曝光补偿:0 焦距:50mm</td></tr></tbody></table><h6 id="高光下的梧桐叶-天空也有点过曝了"><a href="#高光下的梧桐叶-天空也有点过曝了" class="headerlink" title="高光下的梧桐叶(天空也有点过曝了)"></a>高光下的梧桐叶(天空也有点过曝了)</h6><table><thead><tr><th><img src="/2022/10/27/my-first-blog-in-github/%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%89%AB%E8%A1%97_2022.11.12-030.JPG"></th></tr></thead><tbody><tr><td>自动 f&#x2F;11 1&#x2F;800s ISO-2500 曝光补偿:0 焦距:50mm</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​z5总的来说是一款合格的入门级微单，仅仅搭配24-50mm的镜头就能带给我这么多惊喜，未来搭配上50mm f&#x2F;1.8拍人像，24-120mm拍风景的时候效果估计会更好。敬请期待我之后的扫街成果吧！</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;z5的第一次扫街成果照片展示&quot;&gt;&lt;a href=&quot;#z5的第一次扫街成果照片展示&quot; class=&quot;headerlink&quot; title=&quot;z5的第一次扫街成果照片展示&quot;&gt;&lt;/a&gt;z5的第一次扫街成果照片展示&lt;/h3&gt;</summary>
    
    
    
    <category term="Photography" scheme="http://onem.cloud/categories/Photography/"/>
    
    
    <category term="无聊产出" scheme="http://onem.cloud/tags/%E6%97%A0%E8%81%8A%E4%BA%A7%E5%87%BA/"/>
    
    <category term="构图" scheme="http://onem.cloud/tags/%E6%9E%84%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>P3375 【模板】KMP字符串匹配</title>
    <link href="http://onem.cloud/2022/09/01/P3375-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91KMP%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    <id>http://onem.cloud/2022/09/01/P3375-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91KMP%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</id>
    <published>2022-09-01T03:32:16.000Z</published>
    <updated>2022-11-21T15:00:40.039Z</updated>
    
    <content type="html"><![CDATA[<hr><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>KMP算法的精髓在于，它最大化里利用上了上次匹配上的子串，没有低效率的一位一位为开头去寻找，关键在于匹配上的子串可以决定下次开始寻找的位置。其中利用到的原理则是最长相同前缀后缀长度。比如我们已经寻找到了一个二者匹配的局部相同子串abcefabc,那么下次开始寻找（主串下标不变）的位置这则是这个相同子串abc的第4个e，但是如果局部相同的子串是abcdef的话，则下次开始的位置则从头开始判断。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">8</span>;</span><br><span class="line"><span class="type">char</span> s1[N],s2[N];</span><br><span class="line"><span class="type">int</span> len_s1,len_s2,kmp[N];<span class="comment">//kmp代表s2的长度为i时的最长公共前缀后缀 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,s1+<span class="number">1</span>,s2+<span class="number">1</span>);</span><br><span class="line">len_s1=<span class="built_in">strlen</span>(s1+<span class="number">1</span>),len_s2=<span class="built_in">strlen</span>(s2+<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=len_s2;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j&amp;&amp;s2[j+<span class="number">1</span>]!=s2[i])&#123;</span><br><span class="line">j=kmp[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s2[j+<span class="number">1</span>]==s2[i])&#123;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">kmp[i]=j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len_s1;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;s2[j+<span class="number">1</span>]!=s1[i])&#123;</span><br><span class="line">j=kmp[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s2[j+<span class="number">1</span>]==s1[i])&#123;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j==len_s2)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i-len_s2+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len_s2;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,kmp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#define MAXN 1000010</span></span><br><span class="line"><span class="comment">using namespace std;</span></span><br><span class="line"><span class="comment">int kmp[MAXN];//kmp代表当s2的长度为i的时候，此时的前缀（不包含自己）和后缀相同时的最长长度 </span></span><br><span class="line"><span class="comment">int la,lb,j; </span></span><br><span class="line"><span class="comment">char a[MAXN],b[MAXN];</span></span><br><span class="line"><span class="comment">int main()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    cin&gt;&gt;a+1;</span></span><br><span class="line"><span class="comment">    cin&gt;&gt;b+1;</span></span><br><span class="line"><span class="comment">    la=strlen(a+1);</span></span><br><span class="line"><span class="comment">    lb=strlen(b+1);</span></span><br><span class="line"><span class="comment">    for (int i=2;i&lt;=lb;i++)//生成kmp数组，因为i=1的时候不存在真前后缀，故直接跳过 </span></span><br><span class="line"><span class="comment">   &#123;     </span></span><br><span class="line"><span class="comment">   while(j&amp;&amp;b[i]!=b[j+1]) //如果前i-1长度的时候最长相同前缀后缀长度不为0，新增的在i-1后面的字符于j后面的字符不相同 </span></span><br><span class="line"><span class="comment">        j=kmp[j];    // 则向前搜索，看看上一次可以符合嘛 </span></span><br><span class="line"><span class="comment">       if(b[j+1]==b[i])j++;  //当j为0的时候，检查b的第一个元素是否和最后一个元素相同，如果相同则j++//j不是0的时候则是检查新增的字符是否等于j后面的字符  </span></span><br><span class="line"><span class="comment">        kmp[i]=j;//保存当前长度最长相同前缀后缀长度 </span></span><br><span class="line"><span class="comment">       &#125;</span></span><br><span class="line"><span class="comment">    j=0;</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;=la;i++)</span></span><br><span class="line"><span class="comment">   &#123;</span></span><br><span class="line"><span class="comment">          while(j&gt;0&amp;&amp;b[j+1]!=a[i]) </span></span><br><span class="line"><span class="comment">           j=kmp[j];// </span></span><br><span class="line"><span class="comment">          if (b[j+1]==a[i]) </span></span><br><span class="line"><span class="comment">           j++;</span></span><br><span class="line"><span class="comment">          if (j==lb) &#123;cout&lt;&lt;i-lb+1&lt;&lt;endl;j=kmp[j];&#125;</span></span><br><span class="line"><span class="comment">       &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    for (int i=1;i&lt;=lb;i++)</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;kmp[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;*/</span> </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;：我本来打算复习朴素的字符串匹配的方法的，然后打开洛谷准备刷点题，结果发现了这个KMP算法，其实这个算法在我自己推导朴素字符串匹配的时候就有类似的想法了，但是由于没有发现这个最长相同前缀后缀长度的状态转移类似于dp的规律，在已经匹配相同的区域的时候选择下次移动的距离可能这个寻找这个距离耗费的时间都赶上直接朴素寻找了，但是直到今天我深入了解了kmp算法，一个字，妙啊！&lt;/p&gt;</summary>
    
    
    
    <category term="Luogu" scheme="http://onem.cloud/categories/Luogu/"/>
    
    <category term="题解" scheme="http://onem.cloud/categories/Luogu/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="KMP匹配" scheme="http://onem.cloud/tags/KMP%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>P1763 埃及分数 迭代加深搜索加剪枝</title>
    <link href="http://onem.cloud/2022/08/31/P1763-%E5%9F%83%E5%8F%8A%E5%88%86%E6%95%B0-%E8%BF%AD%E4%BB%A3%E5%8A%A0%E6%B7%B1%E6%90%9C%E7%B4%A2%E5%8A%A0%E5%89%AA%E6%9E%9D/"/>
    <id>http://onem.cloud/2022/08/31/P1763-%E5%9F%83%E5%8F%8A%E5%88%86%E6%95%B0-%E8%BF%AD%E4%BB%A3%E5%8A%A0%E6%B7%B1%E6%90%9C%E7%B4%A2%E5%8A%A0%E5%89%AA%E6%9E%9D/</id>
    <published>2022-08-31T13:13:43.000Z</published>
    <updated>2022-11-21T14:57:21.709Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1763">题目链接</a></p><hr><p>先来个迭代搜索的模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num;<span class="comment">//num是当前的限定搜索层数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> step)</span></span>&#123;<span class="comment">//step代表当前层数，从0开始</span></span><br><span class="line"><span class="keyword">if</span>(step==num)&#123;</span><br><span class="line"><span class="keyword">if</span>(到了限定层数但是没达到目标数)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//剪枝</span></span><br><span class="line"><span class="comment">//中间可以加一些处理，比如同一个限定层数但是有多个答案，我们找最优解</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//否则返回1；</span></span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(搜索范围)&#123;<span class="comment">//一般这里的搜索范围需要根据题目条件手动压缩范围剪枝</span></span><br><span class="line"><span class="keyword">if</span>(范围数合法)一些处理或剪枝；</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">dfs</span>(step+<span class="number">1</span>)==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//向下一层寻找</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(num=起点;;num++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">dfs</span>(<span class="number">0</span>)==<span class="number">1</span>)&#123;<span class="keyword">break</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出答案；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>回到正题，本题的考察点无非有以下几点，<strong>1.分数的减法与化简。2.当前剩余寻找分数个数的极限满足答案的值（用来剪枝）。3.相同限定层数下多个答案的最优解处理。</strong>直接上代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a,b,ans[<span class="number">10000</span>],a1[<span class="number">10000</span>],num;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">gcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> k1,<span class="type">long</span> <span class="type">long</span> k2)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k2&gt;k1)&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> remain=k1;</span><br><span class="line">k1=k2;</span><br><span class="line">k2=remain;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(k1%k2!=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> remain=k1%k2;</span><br><span class="line">k1=k2;</span><br><span class="line">k2=remain;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> k2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> step,<span class="type">int</span> lim_step,<span class="type">long</span> <span class="type">long</span> remain_a,<span class="type">long</span> <span class="type">long</span> remain_b)</span>&#123;<span class="comment">//step从0开始， </span></span><br><span class="line"><span class="comment">//printf(&quot;%d %d %d %d\n&quot;,step,lim_step,remain_a,remain_b);</span></span><br><span class="line"><span class="keyword">if</span>(step==lim_step)&#123;</span><br><span class="line"><span class="keyword">if</span>(remain_a!=<span class="number">0</span>||remain_b&gt;<span class="number">1e7</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(a1[step]&lt;ans[step])&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=step;i++)&#123;<span class="comment">//当前最优解的替换</span></span><br><span class="line">ans[i]=a1[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">bool</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> beg=<span class="built_in">ceil</span>(<span class="number">1.0</span>*remain_b/remain_a);</span><br><span class="line"><span class="type">int</span> remain_c=beg;</span><br><span class="line"><span class="keyword">if</span>(beg&lt;=a1[step])&#123;</span><br><span class="line">beg=a1[step]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> end=remain_c*(num-step);<span class="comment">//当前的极限值，即后面所有层数的数不递减才能勉强合法的边界</span></span><br><span class="line"><span class="keyword">if</span>(end&gt;<span class="number">1e7</span>)&#123;</span><br><span class="line">end=<span class="number">1e7</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf(&quot;%d\n&quot;,beg);</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=beg;i&lt;=end;i++)&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> remain_a1=<span class="number">0</span>,remain_b1=<span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> gcd1=gcd(i,remain_b);</span><br><span class="line">remain_b1=remain_b*i/gcd1;</span><br><span class="line">remain_a1=remain_a*(remain_b1/remain_b)-remain_b1/i;</span><br><span class="line"><span class="comment">//printf(&quot;%lld %lld\n&quot;,remain_a1,remain_b1);</span></span><br><span class="line">a1[step+<span class="number">1</span>]=i;</span><br><span class="line"><span class="keyword">if</span>(dfs(step+<span class="number">1</span>,lim_step,remain_a1,remain_b1)==<span class="number">1</span>)&#123;</span><br><span class="line">flag=<span class="number">1</span>;<span class="comment">//这样可以保证不会找到一个答案就立马返回不继续寻找了</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="built_in">memset</span>(ans,<span class="number">127</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line"><span class="keyword">for</span>(num=<span class="number">1</span>;;num++)&#123;</span><br><span class="line"><span class="keyword">if</span>(dfs(<span class="number">0</span>,num,a,b)==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;：作为我a的第一个紫题，这道题写的还是有点吃力的，很多细节处还是有点没搞懂，以至于我做了扩大范围处理，但是总而言之，这类题对基础的要求十分高，剪枝的前提就是你已经熟悉了整个迭代搜索过程，但最后还是a出来了，可喜可贺可喜可贺。&lt;/p&gt;</summary>
    
    
    
    <category term="Luogu" scheme="http://onem.cloud/categories/Luogu/"/>
    
    <category term="题解" scheme="http://onem.cloud/categories/Luogu/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="迭代加深搜索" scheme="http://onem.cloud/tags/%E8%BF%AD%E4%BB%A3%E5%8A%A0%E6%B7%B1%E6%90%9C%E7%B4%A2/"/>
    
    <category term="剪枝优化" scheme="http://onem.cloud/tags/%E5%89%AA%E6%9E%9D%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>POJ 2000:最长公共子上升序列 综合dp问题加前缀保存回溯</title>
    <link href="http://onem.cloud/2022/08/26/POJ-2000-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%8A%E5%8D%87%E5%BA%8F%E5%88%97-%E7%BB%BC%E5%90%88dp%E9%97%AE%E9%A2%98%E5%8A%A0%E5%89%8D%E7%BC%80%E4%BF%9D%E5%AD%98%E5%9B%9E%E6%BA%AF/"/>
    <id>http://onem.cloud/2022/08/26/POJ-2000-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%8A%E5%8D%87%E5%BA%8F%E5%88%97-%E7%BB%BC%E5%90%88dp%E9%97%AE%E9%A2%98%E5%8A%A0%E5%89%8D%E7%BC%80%E4%BF%9D%E5%AD%98%E5%9B%9E%E6%BA%AF/</id>
    <published>2022-08-26T03:27:46.000Z</published>
    <updated>2022-11-21T15:05:53.131Z</updated>
    
    <content type="html"><![CDATA[<hr><p><a href="http://noi.openjudge.cn/ch0206/2000/">题目链接</a></p><hr><p>首先我们通过最长公共子序列这道题知道了这道题的dp构造大概二维就够了，那么我们要解决的就是这里的dp[i][j]代表的意义是什么？首先我们先参考最长公共子序列里的O（n^2）朴素dp方法的dp[i][j]代表的是a数组的1<del>i元素与b数组的1</del>j元素之间的最长公共子序列，这里显然我们就无法保证递增性，因为我们没有保存上次的最大值，最后发现自己无法构造出一个满足情况的dp，最后只好“借鉴一下”网上大佬们的思路。</p><hr><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>我们构造一个dp[i][j]代表a的1~i号元素当以b[j]为结尾时的最长公共上升子序列，<strong>状态转移方程为如果当前a[i]!&#x3D;b[j]，只有当b[j]&lt;a[i]&amp;&amp;mx&lt;dp[i-1][j],这时可以更新每层最大值mx，同时标记当前位置，方便回溯。这样做可以保证我们当a[i]&#x3D;&#x3D;b[j]的时候，接入的公共子序列结尾是小于当前需要接入的数，即保证单调递增。</strong><br>如果a[i]&#x3D;&#x3D;b[j]则可以根据我们找到的最大值的基础上加1，同时赋值之前的保存的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> n,m,a[<span class="number">508</span>],b[<span class="number">508</span>],dp[<span class="number">508</span>][<span class="number">508</span>],per[<span class="number">508</span>][<span class="number">508</span>];<span class="comment">//dp[i][j]代表以a数组的前i项以j结尾的最长上升公共子序列 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">opt</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!dp[x][y])<span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(a[x]!=b[y]&amp;&amp;x)x--;</span><br><span class="line"><span class="built_in">opt</span>(x,per[x][y]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[x]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="type">int</span> mx=<span class="number">0</span>,loc=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">per[i][j]=j;</span><br><span class="line"><span class="keyword">if</span>(b[j]&lt;a[i]&amp;&amp;mx&lt;dp[i<span class="number">-1</span>][j])&#123; <span class="comment">//如果以b[j]结尾的a的前i-1项存在比当前存储的还长的公共序列，且b[j]&lt;a[i]，若a[i]==b[j]时可以接在这个最大长度的后面 </span></span><br><span class="line">mx=dp[i<span class="number">-1</span>][j];</span><br><span class="line">loc=j;<span class="comment">//记录前项的下标 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[i]==b[j])&#123;</span><br><span class="line">dp[i][j]=mx+<span class="number">1</span>;</span><br><span class="line">per[i][j]=loc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> y=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(dp[n][y]&lt;dp[n][i])&#123;</span><br><span class="line">y=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> x=n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[n][y]);</span><br><span class="line"><span class="built_in">opt</span>(x,y);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;：这道题乍一眼看就把我整迷糊了，又是最长上升子序列，又是公共子序列，buff叠满了属于是，我想用最长上升子序列的框架，发现公共的部分不知道如何兼顾，与是开始尝试先找公共子序列，然后通过加一些大小判断来实现这个公共子序列是上升且最长的。&lt;/p&gt;</summary>
    
    
    
    <category term="POJ" scheme="http://onem.cloud/categories/POJ/"/>
    
    <category term="题解" scheme="http://onem.cloud/categories/POJ/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="dp" scheme="http://onem.cloud/tags/dp/"/>
    
    <category term="回溯" scheme="http://onem.cloud/tags/%E5%9B%9E%E6%BA%AF/"/>
    
    <category term="前缀处理" scheme="http://onem.cloud/tags/%E5%89%8D%E7%BC%80%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>P1018 [NOIP2000 提高组] 乘积最大-dp 高精度</title>
    <link href="http://onem.cloud/2022/08/23/P1018-NOIP2000-%E6%8F%90%E9%AB%98%E7%BB%84-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7-dp-%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    <id>http://onem.cloud/2022/08/23/P1018-NOIP2000-%E6%8F%90%E9%AB%98%E7%BB%84-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7-dp-%E9%AB%98%E7%B2%BE%E5%BA%A6/</id>
    <published>2022-08-23T01:46:49.000Z</published>
    <updated>2022-11-21T14:42:06.653Z</updated>
    
    <content type="html"><![CDATA[<hr><p><a href="https://www.luogu.com.cn/problem/P1018">题目链接</a></p><hr><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>显然dp能写，但是要找到状态转移方程是核心，于是我开始手动模拟寻找答案的过程，加入数据是 1 2 3 4 5 插入两个乘号，我们知道如果不插入乘号这这个最大值就是它自己，当插入一个乘号的时候，这个乘号只能从至少2个数开始插入同时我们知道一个乘号会把数字分成前后两段，但是具体要放在哪里这是需要枚举的比如我们寻找前5个数插入1个乘号时的最大值，则枚举过程为前2个数不插入乘号时的最大值乘以后三个数，前3个数不插入乘号时乘以后2个数，前4个数不插入乘号时乘以后面一个数。至此dp的状态转移方程以及dp如何构造已经十分清楚了。<strong><em>我们令dp[i][j]代表在前j个数插入i个乘号的最大值。同时状态转移方程为dp[i][j]&#x3D;max(dp[i][j],dp[i-1][z]</em>[z+1,j]),i-1&lt;z&lt;j</strong><br>因为题目涉及高精度，所以定义为dp[i][j][100]。其他的就是一些比如高精乘以及高精度之间的比较函数之类的基础方法了，细心即可，接下来放ac代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> n,k,arr[<span class="number">50</span>];</span><br><span class="line"><span class="type">char</span> str[<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">7</span>][<span class="number">50</span>][<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a&lt;b)<span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">mult</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="comment">//返回a与[l,r]的乘积 </span></span><br><span class="line"><span class="type">int</span> *b=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>*<span class="built_in">sizeof</span>(<span class="type">int</span>));<span class="comment">//动态分配 </span></span><br><span class="line"><span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*<span class="number">100</span>);</span><br><span class="line"><span class="type">int</span> remain[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=r;i&gt;=l;i--)&#123;</span><br><span class="line">remain[++remain[<span class="number">0</span>]]=arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=remain[<span class="number">0</span>];i++)&#123;<span class="comment">//高精乘法 </span></span><br><span class="line"><span class="type">int</span> w=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=a[<span class="number">0</span>];j++)&#123;</span><br><span class="line">b[j+i<span class="number">-1</span>]=remain[i]*a[j]+b[j+i<span class="number">-1</span>]+w;</span><br><span class="line">w=b[j+i<span class="number">-1</span>]/<span class="number">10</span>;</span><br><span class="line">b[j+i<span class="number">-1</span>]%=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">b[<span class="number">0</span>]=a[<span class="number">0</span>]+i<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(w)&#123;</span><br><span class="line">b[++b[<span class="number">0</span>]]=w%<span class="number">10</span>;</span><br><span class="line">w/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span></span>&#123;<span class="comment">//比较函数 </span></span><br><span class="line"><span class="keyword">if</span>(a[<span class="number">0</span>]&gt;b[<span class="number">0</span>])<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(a[<span class="number">0</span>]&lt;b[<span class="number">0</span>])<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=a[<span class="number">0</span>];i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&gt;b[i])<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(a[i]&lt;b[i])<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str+<span class="number">1</span>);</span><br><span class="line">arr[<span class="number">0</span>]=<span class="built_in">strlen</span>(str+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=arr[<span class="number">0</span>];i++)&#123;</span><br><span class="line">arr[i]=str[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=arr[<span class="number">0</span>];i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">dp[<span class="number">0</span>][i][++dp[<span class="number">0</span>][i][<span class="number">0</span>]]=arr[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">min</span>(k,n<span class="number">-1</span>);i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> z=i;z&lt;j;z++)&#123;</span><br><span class="line"><span class="type">int</span> *c=<span class="built_in">mult</span>(dp[i<span class="number">-1</span>][z],z+<span class="number">1</span>,j);</span><br><span class="line"><span class="type">int</span> judge=<span class="built_in">cmp</span>(dp[i][j],c);</span><br><span class="line"><span class="keyword">if</span>(judge==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(dp[i][j],c,<span class="built_in">sizeof</span>(<span class="type">int</span>)*(c[<span class="number">0</span>]+<span class="number">3</span>));</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">free</span>(c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=dp[k][n][<span class="number">0</span>];i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[k][n][i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;：说实话一开始看到这道题的时候，真的感觉一点思路也没有，但显然什么都不做尝试是没有结果的。于是我开始考虑如果要暴力枚举，会怎样呢，比如dfs，最多40个数，则有39个可插入位置，这全部位置枚举，一共插入6个，时间复杂度则是n^k,感觉有点极限，&lt;del&gt;但可以骗到一点水数据的分（acm赛制当我没说）&lt;/del&gt;。突然我灵光一闪，动态规划是否能够写呢？&lt;/p&gt;</summary>
    
    
    
    <category term="Luogu" scheme="http://onem.cloud/categories/Luogu/"/>
    
    <category term="题解" scheme="http://onem.cloud/categories/Luogu/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="dp" scheme="http://onem.cloud/tags/dp/"/>
    
    <category term="高精度" scheme="http://onem.cloud/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>P8445 射命丸文的取材之旅 构造</title>
    <link href="http://onem.cloud/2022/08/22/P8445-%E5%B0%84%E5%91%BD%E4%B8%B8%E6%96%87%E7%9A%84%E5%8F%96%E6%9D%90%E4%B9%8B%E6%97%85-%E6%9E%84%E9%80%A0/"/>
    <id>http://onem.cloud/2022/08/22/P8445-%E5%B0%84%E5%91%BD%E4%B8%B8%E6%96%87%E7%9A%84%E5%8F%96%E6%9D%90%E4%B9%8B%E6%97%85-%E6%9E%84%E9%80%A0/</id>
    <published>2022-08-22T07:49:02.000Z</published>
    <updated>2022-11-21T14:42:34.215Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P8445">题目链接</a></p><hr><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>这道题是一道十分经典的将题目简化再处理的题目，我们不难发现首先每个数的范围是在0<del>n，那么可能的mex值则为0</del>n+1。其次我们又会发现处理ai&#x3D;&#x3D;bi这种情况会影响我们选择mex的值，其他让我们选择的数对我们都可以很容易的让某个数不出现。所以题目转换为被ai&#x3D;&#x3D;bi划分的片段中，区间长度-mex的最大值。我们可以枚举mex从0~n+1，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span><span class="comment">//令ai==bi的时候为间断点，ai!=bi的时候为摇摆点 </span></span></span><br><span class="line"><span class="type">int</span> n,a[<span class="number">1000008</span>],b[<span class="number">1000008</span>],end[<span class="number">1000008</span>],ans;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">a</span>&#123;</span><br><span class="line"><span class="type">int</span> now_idx;</span><br><span class="line"><span class="type">int</span> nxt;<span class="comment">//上一个间断点结构体在point里的下标 </span></span><br><span class="line">&#125;id;</span><br><span class="line">id point[<span class="number">1000008</span>];</span><br><span class="line"><span class="type">int</span> point_id;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line"><span class="keyword">if</span>(a[i]==b[i])&#123;</span><br><span class="line">point[++point_id].now_idx=i;</span><br><span class="line">point[point_id].nxt=end[a[i]];<span class="comment">//end[a[i]]存放的是上次出现相同值的间断点的下标，如果它是第一次出现则end[a[i]]里面存放的是0； </span></span><br><span class="line">end[a[i]]=point_id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>;u&lt;=n+<span class="number">1</span>;u++)&#123;</span><br><span class="line"><span class="keyword">if</span>(end[u]==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="type">int</span> ans1=n-u;</span><br><span class="line">ans=ans&gt;ans1?ans:ans1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">int</span> end1=n,i=<span class="number">0</span>;<span class="comment">//因为链表是从前向后记的，所以遍历的时候我们从后向前遍历 </span></span><br><span class="line"><span class="keyword">for</span>(i=end[u];i;i=point[i].nxt)&#123;</span><br><span class="line"><span class="type">int</span> idx=point[i].now_idx;</span><br><span class="line"><span class="keyword">if</span>(a[end1]==u)&#123;<span class="comment">//如果当前的右端点是间断点 </span></span><br><span class="line"><span class="keyword">if</span>(end1<span class="number">-1</span>&gt;idx)&#123;<span class="comment">//两个间断点如果相邻就没有答案 </span></span><br><span class="line"><span class="type">int</span> ans1=end1<span class="number">-1</span>-(idx+<span class="number">1</span>)+<span class="number">1</span>-u;</span><br><span class="line">ans=ans&gt;ans1?ans:ans1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//如果右端点不是间断点 </span></span><br><span class="line"><span class="type">int</span> ans1=end1-(idx+<span class="number">1</span>)+<span class="number">1</span>-u;</span><br><span class="line">ans=ans&gt;ans1?ans:ans1;</span><br><span class="line">&#125;</span><br><span class="line">end1=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为可能第一个间断点之前仍然存在一个区间</span></span><br><span class="line"><span class="keyword">if</span>(end1!=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> ans1=end1<span class="number">-1</span><span class="number">-1</span>+<span class="number">1</span>-u;</span><br><span class="line">ans=ans&gt;ans1?ans:ans1;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;构造题一般是一类蕴含某个数学规律的生活日常，需要你简化模型，类比等方法去拨开繁琐的题干抓住问题的关键&quot;&gt;&lt;a href=&quot;#构造题一般是一类蕴含某个数学规律的生活日常，需要你简化模型，类比等方法去拨开繁琐的题干抓住问题的关键&quot; class=&quot;headerlink&quot; title=&quot;构造题一般是一类蕴含某个数学规律的生活日常，需要你简化模型，类比等方法去拨开繁琐的题干抓住问题的关键&quot;&gt;&lt;/a&gt;构造题一般是一类蕴含某个数学规律的生活日常，需要你简化模型，类比等方法去拨开繁琐的题干抓住问题的关键&lt;/h4&gt;</summary>
    
    
    
    <category term="Luogu" scheme="http://onem.cloud/categories/Luogu/"/>
    
    <category term="题解" scheme="http://onem.cloud/categories/Luogu/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="构造" scheme="http://onem.cloud/tags/%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>P1433 吃奶酪 状态压缩dp 时间复杂度O（n^2*2^n）</title>
    <link href="http://onem.cloud/2022/08/16/Luogu-%E9%A2%98%E8%A7%A3P1433/"/>
    <id>http://onem.cloud/2022/08/16/Luogu-%E9%A2%98%E8%A7%A3P1433/</id>
    <published>2022-08-16T04:37:40.000Z</published>
    <updated>2022-11-21T13:55:43.940Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1433">题目链接</a></p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> x[<span class="number">20</span>],y[<span class="number">20</span>],id[<span class="number">20</span>],dis[<span class="number">20</span>][<span class="number">20</span>],f[<span class="number">20</span>][<span class="number">35000</span>],ans;<span class="comment">//f代表当前点为i时，且途径的点集合为j时的总距离的最小值； </span></span><br><span class="line"><span class="type">double</span> <span class="title function_">jishuan</span><span class="params">(<span class="type">double</span> x11,<span class="type">double</span> y11,<span class="type">double</span> x22,<span class="type">double</span> y22)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(x11-x22,<span class="number">2</span>)+<span class="built_in">pow</span>(y11-y22,<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">min</span><span class="params">(<span class="type">double</span> x11,<span class="type">double</span> y11)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x11&lt;=y11)&#123;</span><br><span class="line"><span class="keyword">return</span> x11;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> y11;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>,&amp;x[i],&amp;y[i]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//第i个点 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;<span class="comment">//下一个点 </span></span><br><span class="line"> dis[i][j]=jishuan(x[i],y[i],x[j],y[j]);</span><br><span class="line">dis[j][i]=dis[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">127</span>,<span class="keyword">sizeof</span>(f));<span class="comment">//memset(a,127,sizeof(a));即得到无穷大memset(a,128,sizeof(a));即得到无穷小，与上述的值互为相反数。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">f[i][<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>)]=dis[i][<span class="number">0</span>];</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)&#123;<span class="comment">//途径点的集合 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;<span class="comment">//当前的点 </span></span><br><span class="line"><span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)))&#123;<span class="comment">//当途径点的集合含有当前点的时候 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> z=<span class="number">1</span>;z&lt;=n;z++)&#123;<span class="comment">//前一个点 </span></span><br><span class="line"><span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;(z<span class="number">-1</span>))&amp;&amp;z!=j)&#123;</span><br><span class="line">f[j][i]=min(f[j][i],f[z][i-(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))]+dis[z][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">ans=f[i][(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(f[i][(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>]&lt;ans)&#123;</span><br><span class="line">ans=f[i][(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h4><p>本题的难点在于dp的状态保存与转移，传统dp内存会炸以及暴力搜索会被n&#x3D;15即（15！&gt;&gt;1e8）而卡住，同时本题贪心不可取，可能有局部贪心可以优化但是本人还没发现局部贪心，由于状态压缩dp的时间复杂度有点高，在1e8以内我计算发现n在21以内都没问题所有本题就采用状态压缩来写。</p><hr><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>将数的二进制每一位上的一代表该下标的点以及走过，比如4（10）-&gt;0000 0100 (2)代表走过了第3个点。而 1011 0100代表走过3，5，6，8这4个点。<br>dp[i][j]代表当当前点是第i个点的时候，j是这个途径点的集合的2进制的10进制数，走过所有途径点的最小值。<br>所有状态转移方程就是dp[i][j]&#x3D;min(dp[i][j],dp[z][j-(1&lt;&lt;(i-1))]+dis[i][z]);</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;注意状压dp的细节优化思路，所有的dp题对应状态保存对搜索效率的提升需要有一个大体的感觉。&quot;&gt;&lt;a href=&quot;#注意状压dp的细节优化思路，所有的dp题对应状态保存对搜索效率的提升需要有一个大体的感觉。&quot; class=&quot;headerlink&quot; title=&quot;注意状压dp的细节优化思路，所有的dp题对应状态保存对搜索效率的提升需要有一个大体的感觉。&quot;&gt;&lt;/a&gt;注意状压dp的细节优化思路，所有的dp题对应状态保存对搜索效率的提升需要有一个大体的感觉。&lt;/h4&gt;</summary>
    
    
    
    <category term="Luogu" scheme="http://onem.cloud/categories/Luogu/"/>
    
    <category term="题解" scheme="http://onem.cloud/categories/Luogu/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="状压dp" scheme="http://onem.cloud/tags/%E7%8A%B6%E5%8E%8Bdp/"/>
    
  </entry>
  
  <entry>
    <title>P8482 Number 贪心 高精度 情况模拟</title>
    <link href="http://onem.cloud/2022/08/16/P8482-Number-%E2%80%94%E8%B4%AA%E5%BF%83%EF%BC%8C%E9%AB%98%E7%B2%BE%E5%BA%A6%EF%BC%8C%E6%83%85%E5%86%B5%E6%A8%A1%E6%8B%9F/"/>
    <id>http://onem.cloud/2022/08/16/P8482-Number-%E2%80%94%E8%B4%AA%E5%BF%83%EF%BC%8C%E9%AB%98%E7%B2%BE%E5%BA%A6%EF%BC%8C%E6%83%85%E5%86%B5%E6%A8%A1%E6%8B%9F/</id>
    <published>2022-08-16T04:37:40.000Z</published>
    <updated>2022-11-21T14:21:55.065Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P8482">题目链接</a></p><hr><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>刚开始看到这道题的时候，思路就有点乱，首先当然是如何选出数字组成使得两个数乘积最大。凭着感觉我一开始写了一个将数字从小到大分配，并且实时判断当前的数字谁小，谁小下一个数字就放谁那。当然这个思路有问题，<strong>首先我们知道大的数字一定在高位，所以我们要把大的数字尽可能放在前面，如此一来每个数字就只有两个相同位的不同选择，此时两数和已经固定了</strong>，按照数字知识可知，<strong>两数差越小，积越大</strong>。我们在回首我们分配数字的时候的规律，假如我们你一个我一个这样分，先被分到的a永远大于等于后被分到的b。所以我们要对一个数组，前面取最大，后面取最小，这样这个数组与另一个数组的差就会最小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e7</span>+<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>],a1[N],b1[N],remain[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reversal</span><span class="params">(<span class="type">int</span> *arr)</span></span>&#123;<span class="comment">//翻转，这个里用全局变量对大小要求一点。 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=arr[<span class="number">0</span>];i++)&#123;</span><br><span class="line">remain[i]=arr[arr[<span class="number">0</span>]-i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=arr[<span class="number">0</span>];i++)&#123;</span><br><span class="line">arr[i]=remain[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mult</span><span class="params">(<span class="type">int</span> *arr)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> remain=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=arr[<span class="number">0</span>];i++)&#123;</span><br><span class="line">arr[i]=arr[i]*<span class="number">2</span>+remain;</span><br><span class="line">remain=arr[i]/<span class="number">10</span>;</span><br><span class="line">arr[i]%=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(remain)&#123;</span><br><span class="line">arr[++arr[<span class="number">0</span>]]=remain%<span class="number">10</span>;</span><br><span class="line">remain/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=arr[<span class="number">0</span>];i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chu</span><span class="params">(<span class="type">int</span> *arr)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> arr1=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=arr[<span class="number">0</span>];i++)&#123;</span><br><span class="line">arr1=arr1*<span class="number">10</span>+arr[i];</span><br><span class="line">arr[i]=<span class="number">0</span>;<span class="comment">//！！注意这里的归零，默认当前位除不了，归零 </span></span><br><span class="line"><span class="keyword">if</span>(arr1&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">arr[i]=arr1/<span class="number">2</span>;</span><br><span class="line">arr1%=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=arr[<span class="number">0</span>];i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(flag&amp;&amp;arr[i]==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">flag=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> flag=<span class="number">1</span>,flag1=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">9</span>;i&gt;=<span class="number">0</span>;)&#123;</span><br><span class="line"><span class="keyword">while</span>(a[i])&#123;</span><br><span class="line">a[i]--;</span><br><span class="line"><span class="keyword">if</span>(flag)a1[++a1[<span class="number">0</span>]]=i;</span><br><span class="line"><span class="keyword">else</span> b1[++b1[<span class="number">0</span>]]=i;</span><br><span class="line">flag=!flag;</span><br><span class="line">&#125;</span><br><span class="line">i--;</span><br><span class="line"><span class="keyword">if</span>(flag1)&#123;</span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">0</span>)&#123;<span class="comment">//！！注意这里当且仅当出现大小差异且下一步准备放在小一点的数组时启动，这样可以保证数组-（大-小）-（小-大）这样差最小。 </span></span><br><span class="line">flag1=<span class="number">0</span>;</span><br><span class="line">a[i]--;</span><br><span class="line">b1[++b1[<span class="number">0</span>]]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a1[a1[<span class="number">0</span>]]==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">Reversal</span>(b1);</span><br><span class="line"><span class="built_in">chu</span>(a1);</span><br><span class="line"><span class="built_in">mult</span>(b1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">Reversal</span>(a1);</span><br><span class="line"><span class="built_in">chu</span>(b1);</span><br><span class="line"><span class="built_in">mult</span>(a1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;注意使用贪心算法的局限，同时高精度的加减乘除都要熟悉&quot;&gt;&lt;a href=&quot;#注意使用贪心算法的局限，同时高精度的加减乘除都要熟悉&quot; class=&quot;headerlink&quot; title=&quot;注意使用贪心算法的局限，同时高精度的加减乘除都要熟悉&quot;&gt;&lt;/a&gt;注意使用贪心算法的局限，同时高精度的加减乘除都要熟悉&lt;/h4&gt;</summary>
    
    
    
    <category term="Luogu" scheme="http://onem.cloud/categories/Luogu/"/>
    
    <category term="题解" scheme="http://onem.cloud/categories/Luogu/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="高精度" scheme="http://onem.cloud/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    
    <category term="贪心" scheme="http://onem.cloud/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>P8475 「GLR-R3」雨水 题目思路</title>
    <link href="http://onem.cloud/2022/08/14/Luogu_%E9%A2%98%E8%A7%A3P8475/"/>
    <id>http://onem.cloud/2022/08/14/Luogu_%E9%A2%98%E8%A7%A3P8475/</id>
    <published>2022-08-14T15:50:42.000Z</published>
    <updated>2022-11-21T13:57:27.308Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P8475">题目链接</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span> <span class="comment">// scanf</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e7</span>; <span class="comment">// Set a right value according to your solution.</span></span><br><span class="line"><span class="comment">//const double MAX=pow(2,64); </span></span><br><span class="line"><span class="type">int</span> n, a[MAXN + <span class="number">8</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line">namespace Generator &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> k1, k2;</span><br><span class="line"><span class="type">int</span> thres;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title function_">xorShift128Plus</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> k3 = k1, k4 = k2;</span><br><span class="line">    k1 = k4, k3 ^= (k3 &lt;&lt; <span class="number">23</span>), k2 = k3 ^ k4 ^ (k3 &gt;&gt; <span class="number">17</span>) ^ (k4 &gt;&gt; <span class="number">26</span>);</span><br><span class="line">    <span class="keyword">return</span> k2 + k4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">generate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        a[i] = xorShift128Plus() % thres;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace Generator.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">seach</span><span class="params">(<span class="type">int</span> beg)</span>&#123;<span class="comment">//在[beg,end]的区间内寻找最右最小值 </span></span><br><span class="line"><span class="type">int</span> remain=<span class="number">1e9</span>,remain_id=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=beg;i&lt;=n;i++)&#123;</span><br><span class="line"> <span class="keyword">if</span>(a[i]&lt;remain)&#123;</span><br><span class="line"> remain=a[i];</span><br><span class="line"> remain_id=i;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125; </span><br><span class="line"><span class="keyword">return</span> remain_id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">seach1</span><span class="params">(<span class="type">int</span> min,<span class="type">int</span> beg)</span>&#123;<span class="comment">//beg是这个区间的左区间 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=beg;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&lt;=min)&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> &amp;a1,<span class="type">int</span> &amp;b1)</span>&#123;</span><br><span class="line"><span class="type">int</span> remain=a1;</span><br><span class="line">a1=b1;</span><br><span class="line">b1=remain;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%llu %llu %d&quot;</span>, &amp;Generator::k1, &amp;Generator::k2, &amp;Generator::thres);</span><br><span class="line">    Generator::generate();</span><br><span class="line">   </span><br><span class="line">   <span class="type">int</span> beg=<span class="number">1</span>,end=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span>(beg&lt;=end&amp;&amp;end&lt;=n)&#123;</span><br><span class="line">   <span class="comment">//printf(&quot;%d %d\n&quot;,beg,end);</span></span><br><span class="line">   <span class="keyword">while</span>(a[end]&lt;=a[end+<span class="number">1</span>]&amp;&amp;end+<span class="number">1</span>&lt;=n)&#123;</span><br><span class="line">   end++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(end==n)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> end1=<span class="number">0</span>;</span><br><span class="line">end1=seach(end+<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> remain_min=a[end1];</span><br><span class="line"><span class="keyword">while</span>(a[beg]&lt;=a[end1])&#123;<span class="comment">//关键点1 </span></span><br><span class="line">beg++;</span><br><span class="line">&#125;</span><br><span class="line">end1=seach1(remain_min,end+<span class="number">1</span>);<span class="comment">//关键点2，取最左最小值 </span></span><br><span class="line"><span class="keyword">if</span>(end1)&#123;</span><br><span class="line">swap(a[beg],a[end1]);</span><br><span class="line">end1++;</span><br><span class="line">beg=end=end1;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">    printf(&quot;%d &quot;,a[i]);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">printf(&quot;\n&quot;);*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> remain4=a[i];</span><br><span class="line">ans+=(remain4*i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%llu&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>本题我使用了双指针来实现寻找到单增区间，beg是单增区间的起点下标，end为结束，然后寻找end+1之后的最左最小值下标end1，如果a[beg]&lt;&#x3D;a[end1],则向beg下一位寻找需要交换的数。<br>交换之后，按照题意，新区间的起点为end1+1.<br>最后注意边界问题即可。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;前言：持之以恒，千金不换&quot;&gt;&lt;a href=&quot;#前言：持之以恒，千金不换&quot; class=&quot;headerlink&quot; title=&quot;前言：持之以恒，千金不换&quot;&gt;&lt;/a&gt;前言：持之以恒，千金不换&lt;/h4&gt;</summary>
    
    
    
    <category term="Luogu" scheme="http://onem.cloud/categories/Luogu/"/>
    
    <category term="题解" scheme="http://onem.cloud/categories/Luogu/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="双指针" scheme="http://onem.cloud/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>hexo</title>
    <link href="http://onem.cloud/2022/08/01/hello-world/"/>
    <id>http://onem.cloud/2022/08/01/hello-world/</id>
    <published>2022-07-31T16:00:00.000Z</published>
    <updated>2022-11-21T14:22:51.299Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&amp;quot;My New Post&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="hexo_infor" scheme="http://onem.cloud/categories/hexo-infor/"/>
    
    
    <category term="hexo" scheme="http://onem.cloud/tags/hexo/"/>
    
  </entry>
  
</feed>
