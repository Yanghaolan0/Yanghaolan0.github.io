[{"title":"P1763 埃及分数 迭代加深搜索加剪枝","url":"/2022/08/31/P1763-%E5%9F%83%E5%8F%8A%E5%88%86%E6%95%B0-%E8%BF%AD%E4%BB%A3%E5%8A%A0%E6%B7%B1%E6%90%9C%E7%B4%A2%E5%8A%A0%E5%89%AA%E6%9E%9D/","content":"<p><a href=\"https://www.luogu.com.cn/problem/P1763\">题目链接</a></p>\n<hr>\n<p>先来个迭代搜索的模板</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> num;<span class=\"comment\">//num是当前的限定搜索层数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> step)</span></span>&#123;<span class=\"comment\">//step代表当前层数，从0开始</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(step==num)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(到了限定层数但是没达到目标数)<span class=\"keyword\">return</span> <span class=\"number\">0</span>;<span class=\"comment\">//剪枝</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//中间可以加一些处理，比如同一个限定层数但是有多个答案，我们找最优解</span></span><br><span class=\"line\">\t \t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;<span class=\"comment\">//否则返回1；</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(搜索范围)&#123;<span class=\"comment\">//一般这里的搜索范围需要根据题目条件手动压缩范围剪枝</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(范围数合法)一些处理或剪枝；</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">dfs</span>(step+<span class=\"number\">1</span>)==<span class=\"number\">1</span>)<span class=\"keyword\">return</span> <span class=\"number\">1</span>;<span class=\"comment\">//向下一层寻找</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(num=起点;;num++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">dfs</span>(<span class=\"number\">0</span>)==<span class=\"number\">1</span>)&#123;<span class=\"keyword\">break</span>&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//输出答案；</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h4 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h4><p>回到正题，本题的考察点无非有以下几点，<strong>1.分数的减法与化简。2.当前剩余寻找分数个数的极限满足答案的值（用来剪枝）。3.相同限定层数下多个答案的最优解处理。</strong>直接上代码。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;math.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> a,b,ans[<span class=\"number\">10000</span>],a1[<span class=\"number\">10000</span>],num;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> <span class=\"title function_\">gcd</span><span class=\"params\">(<span class=\"type\">long</span> <span class=\"type\">long</span> k1,<span class=\"type\">long</span> <span class=\"type\">long</span> k2)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(k2&gt;k1)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> <span class=\"type\">long</span> remain=k1;</span><br><span class=\"line\">\t\tk1=k2;</span><br><span class=\"line\">\t\tk2=remain;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(k1%k2!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> <span class=\"type\">long</span> remain=k1%k2;</span><br><span class=\"line\">\t\tk1=k2;</span><br><span class=\"line\">\t\tk2=remain;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> k2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> step,<span class=\"type\">int</span> lim_step,<span class=\"type\">long</span> <span class=\"type\">long</span> remain_a,<span class=\"type\">long</span> <span class=\"type\">long</span> remain_b)</span>&#123;<span class=\"comment\">//step从0开始， </span></span><br><span class=\"line\">\t<span class=\"comment\">//printf(&quot;%d %d %d %d\\n&quot;,step,lim_step,remain_a,remain_b);</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(step==lim_step)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(remain_a!=<span class=\"number\">0</span>||remain_b&gt;<span class=\"number\">1e7</span>)<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a1[step]&lt;ans[step])&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=step;i++)&#123;<span class=\"comment\">//当前最优解的替换</span></span><br><span class=\"line\">\t\t\t\tans[i]=a1[i];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;<span class=\"comment\">//</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">bool</span> flag=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> beg=<span class=\"built_in\">ceil</span>(<span class=\"number\">1.0</span>*remain_b/remain_a);</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> remain_c=beg;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(beg&lt;=a1[step])&#123;</span><br><span class=\"line\">\t\t\tbeg=a1[step]+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> <span class=\"type\">long</span> end=remain_c*(num-step);<span class=\"comment\">//当前的极限值，即后面所有层数的数不递减才能勉强合法的边界</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(end&gt;<span class=\"number\">1e7</span>)&#123;</span><br><span class=\"line\">\t\t\tend=<span class=\"number\">1e7</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//printf(&quot;%d\\n&quot;,beg);</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=beg;i&lt;=end;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">long</span> <span class=\"type\">long</span> remain_a1=<span class=\"number\">0</span>,remain_b1=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"type\">long</span> <span class=\"type\">long</span> gcd1=gcd(i,remain_b);</span><br><span class=\"line\">\t\t\tremain_b1=remain_b*i/gcd1;</span><br><span class=\"line\">\t\t\tremain_a1=remain_a*(remain_b1/remain_b)-remain_b1/i;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//printf(&quot;%lld %lld\\n&quot;,remain_a1,remain_b1);</span></span><br><span class=\"line\">\t\t\ta1[step+<span class=\"number\">1</span>]=i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(dfs(step+<span class=\"number\">1</span>,lim_step,remain_a1,remain_b1)==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tflag=<span class=\"number\">1</span>;<span class=\"comment\">//这样可以保证不会找到一个答案就立马返回不继续寻找了</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> flag;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> \t</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld%lld&quot;</span>,&amp;a,&amp;b);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(ans,<span class=\"number\">127</span>,<span class=\"keyword\">sizeof</span>(ans));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(num=<span class=\"number\">1</span>;;num++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(dfs(<span class=\"number\">0</span>,num,a,b)==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=num;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld &quot;</span>,ans[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["Luogu","题解"],"tags":["迭代加深搜索","剪枝优化"]},{"title":"P1433 吃奶酪 状态压缩dp 时间复杂度O（n^2*2^n）","url":"/2022/08/16/Luogu-%E9%A2%98%E8%A7%A3P1433/","content":"<p><a href=\"https://www.luogu.com.cn/problem/P1433\">题目链接</a></p>\n<hr>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;math.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"><span class=\"type\">double</span> x[<span class=\"number\">20</span>],y[<span class=\"number\">20</span>],id[<span class=\"number\">20</span>],dis[<span class=\"number\">20</span>][<span class=\"number\">20</span>],f[<span class=\"number\">20</span>][<span class=\"number\">35000</span>],ans;<span class=\"comment\">//f代表当前点为i时，且途径的点集合为j时的总距离的最小值； </span></span><br><span class=\"line\"><span class=\"type\">double</span> <span class=\"title function_\">jishuan</span><span class=\"params\">(<span class=\"type\">double</span> x11,<span class=\"type\">double</span> y11,<span class=\"type\">double</span> x22,<span class=\"type\">double</span> y22)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">sqrt</span>(<span class=\"built_in\">pow</span>(x11-x22,<span class=\"number\">2</span>)+<span class=\"built_in\">pow</span>(y11-y22,<span class=\"number\">2</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">double</span> <span class=\"title function_\">min</span><span class=\"params\">(<span class=\"type\">double</span> x11,<span class=\"type\">double</span> y11)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x11&lt;=y11)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> x11;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> y11;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lf%lf&quot;</span>,&amp;x[i],&amp;y[i]);</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;<span class=\"comment\">//第i个点 </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=i+<span class=\"number\">1</span>;j&lt;=n;j++)&#123;<span class=\"comment\">//下一个点 </span></span><br><span class=\"line\">\t\t\t dis[i][j]=jishuan(x[i],y[i],x[j],y[j]);</span><br><span class=\"line\">\t\t\tdis[j][i]=dis[i][j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(f,<span class=\"number\">127</span>,<span class=\"keyword\">sizeof</span>(f));<span class=\"comment\">//memset(a,127,sizeof(a));即得到无穷大memset(a,128,sizeof(a));即得到无穷小，与上述的值互为相反数。</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tf[i][<span class=\"number\">1</span>&lt;&lt;(i<span class=\"number\">-1</span>)]=dis[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;(<span class=\"number\">1</span>&lt;&lt;n);i++)&#123;<span class=\"comment\">//途径点的集合 </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)&#123;<span class=\"comment\">//当前的点 </span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(i&amp;(<span class=\"number\">1</span>&lt;&lt;(j<span class=\"number\">-1</span>)))&#123;<span class=\"comment\">//当途径点的集合含有当前点的时候 </span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> z=<span class=\"number\">1</span>;z&lt;=n;z++)&#123;<span class=\"comment\">//前一个点 </span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span>(i&amp;(<span class=\"number\">1</span>&lt;&lt;(z<span class=\"number\">-1</span>))&amp;&amp;z!=j)&#123;</span><br><span class=\"line\">\t\t\t\t\t\tf[j][i]=min(f[j][i],f[z][i-(<span class=\"number\">1</span>&lt;&lt;(j<span class=\"number\">-1</span>))]+dis[z][j]);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tans=f[i][(<span class=\"number\">1</span>&lt;&lt;n)<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(f[i][(<span class=\"number\">1</span>&lt;&lt;n)<span class=\"number\">-1</span>]&lt;ans)&#123;</span><br><span class=\"line\">\t\t\t\t\tans=f[i][(<span class=\"number\">1</span>&lt;&lt;n)<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.2lf&quot;</span>,ans);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h4><p>本题的难点在于dp的状态保存与转移，传统dp内存会炸以及暴力搜索会被n&#x3D;15即（15！&gt;&gt;1e8）而卡住，同时本题贪心不可取，可能有局部贪心可以优化但是本人还没发现局部贪心，由于状态压缩dp的时间复杂度有点高，在1e8以内我计算发现n在21以内都没问题所有本题就采用状态压缩来写。</p>\n<hr>\n<h4 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h4><p>将数的二进制每一位上的一代表该下标的点以及走过，比如4（10）-&gt;0000 0100 (2)代表走过了第3个点。而 1011 0100代表走过3，5，6，8这4个点。<br>dp[i][j]代表当当前点是第i个点的时候，j是这个途径点的集合的2进制的10进制数，走过所有途径点的最小值。<br>所有状态转移方程就是dp[i][j]&#x3D;min(dp[i][j],dp[z][j-(1&lt;&lt;(i-1))]+dis[i][z]);</p>","categories":["Luogu","题解"],"tags":["状压dp"]},{"title":"P8475 「GLR-R3」雨水 题目思路","url":"/2022/08/14/Luogu_%E9%A2%98%E8%A7%A3P8475/","content":"<p><a href=\"https://www.luogu.com.cn/problem/P8475\">题目链接</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdio&gt;</span> <span class=\"comment\">// scanf</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;math.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">1e7</span>; <span class=\"comment\">// Set a right value according to your solution.</span></span><br><span class=\"line\"><span class=\"comment\">//const double MAX=pow(2,64); </span></span><br><span class=\"line\"><span class=\"type\">int</span> n, a[MAXN + <span class=\"number\">8</span>];</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ans;</span><br><span class=\"line\">namespace Generator &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> k1, k2;</span><br><span class=\"line\"><span class=\"type\">int</span> thres;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> <span class=\"title function_\">xorShift128Plus</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> k3 = k1, k4 = k2;</span><br><span class=\"line\">    k1 = k4, k3 ^= (k3 &lt;&lt; <span class=\"number\">23</span>), k2 = k3 ^ k4 ^ (k3 &gt;&gt; <span class=\"number\">17</span>) ^ (k4 &gt;&gt; <span class=\"number\">26</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> k2 + k4;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title function_\">generate</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">        a[i] = xorShift128Plus() % thres;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"comment\">// namespace Generator.</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">seach</span><span class=\"params\">(<span class=\"type\">int</span> beg)</span>&#123;<span class=\"comment\">//在[beg,end]的区间内寻找最右最小值 </span></span><br><span class=\"line\">\t<span class=\"type\">int</span> remain=<span class=\"number\">1e9</span>,remain_id=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=beg;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t \t<span class=\"keyword\">if</span>(a[i]&lt;remain)&#123;</span><br><span class=\"line\">\t \t\tremain=a[i];</span><br><span class=\"line\">\t \t\tremain_id=i;</span><br><span class=\"line\">\t\t &#125;</span><br><span class=\"line\">\t &#125; </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> remain_id;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">seach1</span><span class=\"params\">(<span class=\"type\">int</span> min,<span class=\"type\">int</span> beg)</span>&#123;<span class=\"comment\">//beg是这个区间的左区间 </span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i&gt;=beg;i--)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a[i]&lt;=min)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(<span class=\"type\">int</span> &amp;a1,<span class=\"type\">int</span> &amp;b1)</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> remain=a1;</span><br><span class=\"line\">\ta1=b1;</span><br><span class=\"line\">\tb1=remain;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;n);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%llu %llu %d&quot;</span>, &amp;Generator::k1, &amp;Generator::k2, &amp;Generator::thres);</span><br><span class=\"line\">    Generator::generate();</span><br><span class=\"line\">   </span><br><span class=\"line\">   \t<span class=\"type\">int</span> beg=<span class=\"number\">1</span>,end=<span class=\"number\">1</span>;</span><br><span class=\"line\">   \t<span class=\"keyword\">while</span>(beg&lt;=end&amp;&amp;end&lt;=n)&#123;</span><br><span class=\"line\">   \t\t<span class=\"comment\">//printf(&quot;%d %d\\n&quot;,beg,end);</span></span><br><span class=\"line\">   \t<span class=\"keyword\">while</span>(a[end]&lt;=a[end+<span class=\"number\">1</span>]&amp;&amp;end+<span class=\"number\">1</span>&lt;=n)&#123;</span><br><span class=\"line\">   \t\tend++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(end==n)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> end1=<span class=\"number\">0</span>;</span><br><span class=\"line\">\tend1=seach(end+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> remain_min=a[end1];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(a[beg]&lt;=a[end1])&#123;<span class=\"comment\">//关键点1 </span></span><br><span class=\"line\">\t\tbeg++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tend1=seach1(remain_min,end+<span class=\"number\">1</span>);<span class=\"comment\">//关键点2，取最左最小值 </span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(end1)&#123;</span><br><span class=\"line\">\tswap(a[beg],a[end1]);</span><br><span class=\"line\">\tend1++;</span><br><span class=\"line\">\tbeg=end=end1;&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">/* for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">    \tprintf(&quot;%d &quot;,a[i]);</span></span><br><span class=\"line\"><span class=\"comment\">\t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\tprintf(&quot;\\n&quot;);*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> remain4=a[i];</span><br><span class=\"line\">\t\tans+=(remain4*i);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%llu&quot;</span>,ans);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h4><p>本题我使用了双指针来实现寻找到单增区间，beg是单增区间的起点下标，end为结束，然后寻找end+1之后的最左最小值下标end1，如果a[beg]&lt;&#x3D;a[end1],则向beg下一位寻找需要交换的数。<br>交换之后，按照题意，新区间的起点为end1+1.<br>最后注意边界问题即可。</p>","categories":["Luogu","题解"],"tags":["双指针"]},{"title":"P1018 [NOIP2000 提高组] 乘积最大-dp 高精度","url":"/2022/08/23/P1018-NOIP2000-%E6%8F%90%E9%AB%98%E7%BB%84-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7-dp-%E9%AB%98%E7%B2%BE%E5%BA%A6/","content":"<hr>\n<p><a href=\"https://www.luogu.com.cn/problem/P1018\">题目链接</a></p>\n<hr>\n<h4 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h4><p>显然dp能写，但是要找到状态转移方程是核心，于是我开始手动模拟寻找答案的过程，加入数据是 1 2 3 4 5 插入两个乘号，我们知道如果不插入乘号这这个最大值就是它自己，当插入一个乘号的时候，这个乘号只能从至少2个数开始插入同时我们知道一个乘号会把数字分成前后两段，但是具体要放在哪里这是需要枚举的比如我们寻找前5个数插入1个乘号时的最大值，则枚举过程为前2个数不插入乘号时的最大值乘以后三个数，前3个数不插入乘号时乘以后2个数，前4个数不插入乘号时乘以后面一个数。至此dp的状态转移方程以及dp如何构造已经十分清楚了。<strong><em>我们令dp[i][j]代表在前j个数插入i个乘号的最大值。同时状态转移方程为dp[i][j]&#x3D;max(dp[i][j],dp[i-1][z]</em>[z+1,j]),i-1&lt;z&lt;j</strong><br>因为题目涉及高精度，所以定义为dp[i][j][100]。其他的就是一些比如高精乘以及高精度之间的比较函数之类的基础方法了，细心即可，接下来放ac代码。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> n,k,arr[<span class=\"number\">50</span>];</span><br><span class=\"line\"><span class=\"type\">char</span> str[<span class=\"number\">50</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> dp[<span class=\"number\">7</span>][<span class=\"number\">50</span>][<span class=\"number\">100</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">min</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(a&lt;b)<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> *<span class=\"title\">mult</span><span class=\"params\">(<span class=\"type\">int</span> *a,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;<span class=\"comment\">//返回a与[l,r]的乘积 </span></span><br><span class=\"line\">\t<span class=\"type\">int</span> *b=(<span class=\"type\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"number\">100</span>*<span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>));<span class=\"comment\">//动态分配 </span></span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(b,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>)*<span class=\"number\">100</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> remain[<span class=\"number\">100</span>]=&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=r;i&gt;=l;i--)&#123;</span><br><span class=\"line\">\t\tremain[++remain[<span class=\"number\">0</span>]]=arr[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=remain[<span class=\"number\">0</span>];i++)&#123;<span class=\"comment\">//高精乘法 </span></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> w=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=a[<span class=\"number\">0</span>];j++)&#123;</span><br><span class=\"line\">\t\t\tb[j+i<span class=\"number\">-1</span>]=remain[i]*a[j]+b[j+i<span class=\"number\">-1</span>]+w;</span><br><span class=\"line\">\t\t\tw=b[j+i<span class=\"number\">-1</span>]/<span class=\"number\">10</span>;</span><br><span class=\"line\">\t\t\tb[j+i<span class=\"number\">-1</span>]%=<span class=\"number\">10</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb[<span class=\"number\">0</span>]=a[<span class=\"number\">0</span>]+i<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(w)&#123;</span><br><span class=\"line\">\t\t\tb[++b[<span class=\"number\">0</span>]]=w%<span class=\"number\">10</span>;</span><br><span class=\"line\">\t\t\tw/=<span class=\"number\">10</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"type\">int</span> *a,<span class=\"type\">int</span> *b)</span></span>&#123;<span class=\"comment\">//比较函数 </span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(a[<span class=\"number\">0</span>]&gt;b[<span class=\"number\">0</span>])<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(a[<span class=\"number\">0</span>]&lt;b[<span class=\"number\">0</span>])<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=a[<span class=\"number\">0</span>];i&gt;<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a[i]&gt;b[i])<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a[i]&lt;b[i])<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>,str+<span class=\"number\">1</span>);</span><br><span class=\"line\">\tarr[<span class=\"number\">0</span>]=<span class=\"built_in\">strlen</span>(str+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=arr[<span class=\"number\">0</span>];i++)&#123;</span><br><span class=\"line\">\t\tarr[i]=str[i]-<span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=arr[<span class=\"number\">0</span>];i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=i;j&gt;<span class=\"number\">0</span>;j--)&#123;</span><br><span class=\"line\">\t\t\tdp[<span class=\"number\">0</span>][i][++dp[<span class=\"number\">0</span>][i][<span class=\"number\">0</span>]]=arr[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"built_in\">min</span>(k,n<span class=\"number\">-1</span>);i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=i+<span class=\"number\">1</span>;j&lt;=n;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> z=i;z&lt;j;z++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">int</span> *c=<span class=\"built_in\">mult</span>(dp[i<span class=\"number\">-1</span>][z],z+<span class=\"number\">1</span>,j);</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">int</span> judge=<span class=\"built_in\">cmp</span>(dp[i][j],c);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(judge==<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">memcpy</span>(dp[i][j],c,<span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>)*(c[<span class=\"number\">0</span>]+<span class=\"number\">3</span>));</span><br><span class=\"line\">\t\t\t\t&#125; </span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">free</span>(c);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=dp[k][n][<span class=\"number\">0</span>];i&gt;<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,dp[k][n][i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>","categories":["Luogu","题解"],"tags":["dp","高精度"]},{"title":"P3375 【模板】KMP字符串匹配","url":"/2022/09/01/P3375-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91KMP%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/","content":"<hr>\n<h4 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h4><p>KMP算法的精髓在于，它最大化里利用上了上次匹配上的子串，没有低效率的一位一位为开头去寻找，关键在于匹配上的子串可以决定下次开始寻找的位置。其中利用到的原理则是最长相同前缀后缀长度。比如我们已经寻找到了一个二者匹配的局部相同子串abcefabc,那么下次开始寻找（主串下标不变）的位置这则是这个相同子串abc的第4个e，但是如果局部相同的子串是abcdef的话，则下次开始的位置则从头开始判断。</p>\n<hr>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N=<span class=\"number\">1e6</span>+<span class=\"number\">8</span>;</span><br><span class=\"line\"><span class=\"type\">char</span> s1[N],s2[N];</span><br><span class=\"line\"><span class=\"type\">int</span> len_s1,len_s2,kmp[N];<span class=\"comment\">//kmp代表s2的长度为i时的最长公共前缀后缀 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s%s&quot;</span>,s1+<span class=\"number\">1</span>,s2+<span class=\"number\">1</span>);</span><br><span class=\"line\">\tlen_s1=<span class=\"built_in\">strlen</span>(s1+<span class=\"number\">1</span>),len_s2=<span class=\"built_in\">strlen</span>(s2+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> j=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=len_s2;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(j&amp;&amp;s2[j+<span class=\"number\">1</span>]!=s2[i])&#123;</span><br><span class=\"line\">\t\t\tj=kmp[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(s2[j+<span class=\"number\">1</span>]==s2[i])&#123;</span><br><span class=\"line\">\t\t\tj++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tkmp[i]=j;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t j=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=len_s1;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(j&gt;<span class=\"number\">0</span>&amp;&amp;s2[j+<span class=\"number\">1</span>]!=s1[i])&#123;</span><br><span class=\"line\">\t\t\tj=kmp[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(s2[j+<span class=\"number\">1</span>]==s1[i])&#123;</span><br><span class=\"line\">\t\t\tj++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(j==len_s2)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,i-len_s2+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=len_s2;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>,kmp[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*#include&lt;iostream&gt;</span></span><br><span class=\"line\"><span class=\"comment\">#include&lt;cstring&gt;</span></span><br><span class=\"line\"><span class=\"comment\">#define MAXN 1000010</span></span><br><span class=\"line\"><span class=\"comment\">using namespace std;</span></span><br><span class=\"line\"><span class=\"comment\">int kmp[MAXN];//kmp代表当s2的长度为i的时候，此时的前缀（不包含自己）和后缀相同时的最长长度 </span></span><br><span class=\"line\"><span class=\"comment\">int la,lb,j; </span></span><br><span class=\"line\"><span class=\"comment\">char a[MAXN],b[MAXN];</span></span><br><span class=\"line\"><span class=\"comment\">int main()</span></span><br><span class=\"line\"><span class=\"comment\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\">    cin&gt;&gt;a+1;</span></span><br><span class=\"line\"><span class=\"comment\">    cin&gt;&gt;b+1;</span></span><br><span class=\"line\"><span class=\"comment\">    la=strlen(a+1);</span></span><br><span class=\"line\"><span class=\"comment\">    lb=strlen(b+1);</span></span><br><span class=\"line\"><span class=\"comment\">    for (int i=2;i&lt;=lb;i++)//生成kmp数组，因为i=1的时候不存在真前后缀，故直接跳过 </span></span><br><span class=\"line\"><span class=\"comment\">\t   &#123;     </span></span><br><span class=\"line\"><span class=\"comment\">\t   while(j&amp;&amp;b[i]!=b[j+1]) //如果前i-1长度的时候最长相同前缀后缀长度不为0，新增的在i-1后面的字符于j后面的字符不相同 </span></span><br><span class=\"line\"><span class=\"comment\">        j=kmp[j];    // 则向前搜索，看看上一次可以符合嘛 </span></span><br><span class=\"line\"><span class=\"comment\">       if(b[j+1]==b[i])j++;  //当j为0的时候，检查b的第一个元素是否和最后一个元素相同，如果相同则j++//j不是0的时候则是检查新增的字符是否等于j后面的字符  </span></span><br><span class=\"line\"><span class=\"comment\">        kmp[i]=j;//保存当前长度最长相同前缀后缀长度 </span></span><br><span class=\"line\"><span class=\"comment\">       &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    j=0;</span></span><br><span class=\"line\"><span class=\"comment\">    for(int i=1;i&lt;=la;i++)</span></span><br><span class=\"line\"><span class=\"comment\">\t   &#123;</span></span><br><span class=\"line\"><span class=\"comment\">          while(j&gt;0&amp;&amp;b[j+1]!=a[i]) </span></span><br><span class=\"line\"><span class=\"comment\">           j=kmp[j];// </span></span><br><span class=\"line\"><span class=\"comment\">          if (b[j+1]==a[i]) </span></span><br><span class=\"line\"><span class=\"comment\">           j++;</span></span><br><span class=\"line\"><span class=\"comment\">          if (j==lb) &#123;cout&lt;&lt;i-lb+1&lt;&lt;endl;j=kmp[j];&#125;</span></span><br><span class=\"line\"><span class=\"comment\">       &#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    for (int i=1;i&lt;=lb;i++)</span></span><br><span class=\"line\"><span class=\"comment\">    cout&lt;&lt;kmp[i]&lt;&lt;&quot; &quot;;</span></span><br><span class=\"line\"><span class=\"comment\">    return 0;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;*/</span> </span><br></pre></td></tr></table></figure>","categories":["Luogu","题解"],"tags":["KMP匹配"]},{"title":"P8445 射命丸文的取材之旅 构造","url":"/2022/08/22/P8445-%E5%B0%84%E5%91%BD%E4%B8%B8%E6%96%87%E7%9A%84%E5%8F%96%E6%9D%90%E4%B9%8B%E6%97%85-%E6%9E%84%E9%80%A0/","content":"<p><a href=\"https://www.luogu.com.cn/problem/P8445\">题目链接</a></p>\n<hr>\n<h4 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h4><p>这道题是一道十分经典的将题目简化再处理的题目，我们不难发现首先每个数的范围是在0<del>n，那么可能的mex值则为0</del>n+1。其次我们又会发现处理ai&#x3D;&#x3D;bi这种情况会影响我们选择mex的值，其他让我们选择的数对我们都可以很容易的让某个数不出现。所以题目转换为被ai&#x3D;&#x3D;bi划分的片段中，区间长度-mex的最大值。我们可以枚举mex从0~n+1，代码如下</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span><span class=\"comment\">//令ai==bi的时候为间断点，ai!=bi的时候为摇摆点 </span></span></span><br><span class=\"line\"><span class=\"type\">int</span> n,a[<span class=\"number\">1000008</span>],b[<span class=\"number\">1000008</span>],end[<span class=\"number\">1000008</span>],ans;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">a</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> now_idx;</span><br><span class=\"line\">\t<span class=\"type\">int</span> nxt;<span class=\"comment\">//上一个间断点结构体在point里的下标 </span></span><br><span class=\"line\">&#125;id;</span><br><span class=\"line\">id point[<span class=\"number\">1000008</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> point_id;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a[i]==b[i])&#123;</span><br><span class=\"line\">\t\t\tpoint[++point_id].now_idx=i;</span><br><span class=\"line\">\t\t\tpoint[point_id].nxt=end[a[i]];<span class=\"comment\">//end[a[i]]存放的是上次出现相同值的间断点的下标，如果它是第一次出现则end[a[i]]里面存放的是0； </span></span><br><span class=\"line\">\t\t\tend[a[i]]=point_id;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> u=<span class=\"number\">0</span>;u&lt;=n+<span class=\"number\">1</span>;u++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(end[u]==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> ans1=n-u;</span><br><span class=\"line\">\t\t\tans=ans&gt;ans1?ans:ans1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> end1=n,i=<span class=\"number\">0</span>;<span class=\"comment\">//因为链表是从前向后记的，所以遍历的时候我们从后向前遍历 </span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(i=end[u];i;i=point[i].nxt)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">int</span> idx=point[i].now_idx;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(a[end1]==u)&#123;<span class=\"comment\">//如果当前的右端点是间断点 </span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span>(end1<span class=\"number\">-1</span>&gt;idx)&#123;<span class=\"comment\">//两个间断点如果相邻就没有答案 </span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"type\">int</span> ans1=end1<span class=\"number\">-1</span>-(idx+<span class=\"number\">1</span>)+<span class=\"number\">1</span>-u;</span><br><span class=\"line\">\t\t\t\t\t\tans=ans&gt;ans1?ans:ans1;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span>&#123;<span class=\"comment\">//如果右端点不是间断点 </span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"type\">int</span> ans1=end1-(idx+<span class=\"number\">1</span>)+<span class=\"number\">1</span>-u;</span><br><span class=\"line\">\t\t\t\t\tans=ans&gt;ans1?ans:ans1;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tend1=idx;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//因为可能第一个间断点之前仍然存在一个区间</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(end1!=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">int</span> ans1=end1<span class=\"number\">-1</span><span class=\"number\">-1</span>+<span class=\"number\">1</span>-u;</span><br><span class=\"line\">\t\t\t\tans=ans&gt;ans1?ans:ans1;</span><br><span class=\"line\">\t\t\t&#125; </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,ans);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","categories":["Luogu","题解"],"tags":["构造"]},{"title":"P8482 Number 贪心 高精度 情况模拟","url":"/2022/08/16/P8482-Number-%E2%80%94%E8%B4%AA%E5%BF%83%EF%BC%8C%E9%AB%98%E7%B2%BE%E5%BA%A6%EF%BC%8C%E6%83%85%E5%86%B5%E6%A8%A1%E6%8B%9F/","content":"<p><a href=\"https://www.luogu.com.cn/problem/P8482\">题目链接</a></p>\n<hr>\n<h4 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h4><p>刚开始看到这道题的时候，思路就有点乱，首先当然是如何选出数字组成使得两个数乘积最大。凭着感觉我一开始写了一个将数字从小到大分配，并且实时判断当前的数字谁小，谁小下一个数字就放谁那。当然这个思路有问题，<strong>首先我们知道大的数字一定在高位，所以我们要把大的数字尽可能放在前面，如此一来每个数字就只有两个相同位的不同选择，此时两数和已经固定了</strong>，按照数字知识可知，<strong>两数差越小，积越大</strong>。我们在回首我们分配数字的时候的规律，假如我们你一个我一个这样分，先被分到的a永远大于等于后被分到的b。所以我们要对一个数组，前面取最大，后面取最小，这样这个数组与另一个数组的差就会最小。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N=<span class=\"number\">1e7</span>+<span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> a[<span class=\"number\">10</span>],a1[N],b1[N],remain[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Reversal</span><span class=\"params\">(<span class=\"type\">int</span> *arr)</span></span>&#123;<span class=\"comment\">//翻转，这个里用全局变量对大小要求一点。 </span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=arr[<span class=\"number\">0</span>];i++)&#123;</span><br><span class=\"line\">\t\tremain[i]=arr[arr[<span class=\"number\">0</span>]-i+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=arr[<span class=\"number\">0</span>];i++)&#123;</span><br><span class=\"line\">\t\tarr[i]=remain[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mult</span><span class=\"params\">(<span class=\"type\">int</span> *arr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> remain=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=arr[<span class=\"number\">0</span>];i++)&#123;</span><br><span class=\"line\">\t\tarr[i]=arr[i]*<span class=\"number\">2</span>+remain;</span><br><span class=\"line\">\t\tremain=arr[i]/<span class=\"number\">10</span>;</span><br><span class=\"line\">\t\tarr[i]%=<span class=\"number\">10</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(remain)&#123;</span><br><span class=\"line\">\t\tarr[++arr[<span class=\"number\">0</span>]]=remain%<span class=\"number\">10</span>;</span><br><span class=\"line\">\t\tremain/=<span class=\"number\">10</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=arr[<span class=\"number\">0</span>];i&gt;<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,arr[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">chu</span><span class=\"params\">(<span class=\"type\">int</span> *arr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> arr1=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=arr[<span class=\"number\">0</span>];i++)&#123;</span><br><span class=\"line\">\t\tarr1=arr1*<span class=\"number\">10</span>+arr[i];</span><br><span class=\"line\">\t\tarr[i]=<span class=\"number\">0</span>;<span class=\"comment\">//！！注意这里的归零，默认当前位除不了，归零 </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(arr1&gt;=<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t\t\tarr[i]=arr1/<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\tarr1%=<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> flag=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=arr[<span class=\"number\">0</span>];i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(flag&amp;&amp;arr[i]==<span class=\"number\">0</span>)<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\tflag=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,arr[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> flag=<span class=\"number\">1</span>,flag1=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">9</span>;i&gt;=<span class=\"number\">0</span>;)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(a[i])&#123;</span><br><span class=\"line\">\t\t\ta[i]--;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(flag)a1[++a1[<span class=\"number\">0</span>]]=i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> b1[++b1[<span class=\"number\">0</span>]]=i;</span><br><span class=\"line\">\t\t\tflag=!flag;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ti--;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(flag1)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(flag==<span class=\"number\">0</span>)&#123;<span class=\"comment\">//！！注意这里当且仅当出现大小差异且下一步准备放在小一点的数组时启动，这样可以保证数组-（大-小）-（小-大）这样差最小。 </span></span><br><span class=\"line\">\t\t\t\tflag1=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t\ta[i]--;</span><br><span class=\"line\">\t\t\t\tb1[++b1[<span class=\"number\">0</span>]]=i;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(a1[a1[<span class=\"number\">0</span>]]==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">Reversal</span>(b1);</span><br><span class=\"line\">\t\t<span class=\"built_in\">chu</span>(a1);</span><br><span class=\"line\">\t\t<span class=\"built_in\">mult</span>(b1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">Reversal</span>(a1);</span><br><span class=\"line\">\t\t<span class=\"built_in\">chu</span>(b1);</span><br><span class=\"line\">\t\t<span class=\"built_in\">mult</span>(a1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["Luogu","题解"],"tags":["高精度","贪心"]},{"title":"POJ 2000:最长公共子上升序列 综合dp问题加前缀保存回溯","url":"/2022/08/26/POJ-2000-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%8A%E5%8D%87%E5%BA%8F%E5%88%97-%E7%BB%BC%E5%90%88dp%E9%97%AE%E9%A2%98%E5%8A%A0%E5%89%8D%E7%BC%80%E4%BF%9D%E5%AD%98%E5%9B%9E%E6%BA%AF/","content":"<hr>\n<p><a href=\"http://noi.openjudge.cn/ch0206/2000/\">题目链接</a></p>\n<hr>\n<p>首先我们通过最长公共子序列这道题知道了这道题的dp构造大概二维就够了，那么我们要解决的就是这里的dp[i][j]代表的意义是什么？首先我们先参考最长公共子序列里的O（n^2）朴素dp方法的dp[i][j]代表的是a数组的1<del>i元素与b数组的1</del>j元素之间的最长公共子序列，这里显然我们就无法保证递增性，因为我们没有保存上次的最大值，最后发现自己无法构造出一个满足情况的dp，最后只好“借鉴一下”网上大佬们的思路。</p>\n<hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>我们构造一个dp[i][j]代表a的1~i号元素当以b[j]为结尾时的最长公共上升子序列，<strong>状态转移方程为如果当前a[i]!&#x3D;b[j]，只有当b[j]&lt;a[i]&amp;&amp;mx&lt;dp[i-1][j],这时可以更新每层最大值mx，同时标记当前位置，方便回溯。这样做可以保证我们当a[i]&#x3D;&#x3D;b[j]的时候，接入的公共子序列结尾是小于当前需要接入的数，即保证单调递增。</strong><br>如果a[i]&#x3D;&#x3D;b[j]则可以根据我们找到的最大值的基础上加1，同时赋值之前的保存的位置。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> n,m,a[<span class=\"number\">508</span>],b[<span class=\"number\">508</span>],dp[<span class=\"number\">508</span>][<span class=\"number\">508</span>],per[<span class=\"number\">508</span>][<span class=\"number\">508</span>];<span class=\"comment\">//dp[i][j]代表以a数组的前i项以j结尾的最长上升公共子序列 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">opt</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!dp[x][y])<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(a[x]!=b[y]&amp;&amp;x)x--;</span><br><span class=\"line\">\t\t<span class=\"built_in\">opt</span>(x,per[x][y]);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>,a[x]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;m);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mx=<span class=\"number\">0</span>,loc=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;j++)&#123;</span><br><span class=\"line\">\t\t\tdp[i][j]=dp[i<span class=\"number\">-1</span>][j];</span><br><span class=\"line\">\t\t\tper[i][j]=j;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(b[j]&lt;a[i]&amp;&amp;mx&lt;dp[i<span class=\"number\">-1</span>][j])&#123; <span class=\"comment\">//如果以b[j]结尾的a的前i-1项存在比当前存储的还长的公共序列，且b[j]&lt;a[i]，若a[i]==b[j]时可以接在这个最大长度的后面 </span></span><br><span class=\"line\">\t\t\t\tmx=dp[i<span class=\"number\">-1</span>][j];</span><br><span class=\"line\">\t\t\t\tloc=j;<span class=\"comment\">//记录前项的下标 </span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a[i]==b[j])&#123;</span><br><span class=\"line\">\t\t\t\tdp[i][j]=mx+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\tper[i][j]=loc;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> y=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(dp[n][y]&lt;dp[n][i])&#123;</span><br><span class=\"line\">\t\t\ty=i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x=n;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,dp[n][y]);</span><br><span class=\"line\">\t<span class=\"built_in\">opt</span>(x,y);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>","categories":["POJ","题解"],"tags":["dp","回溯","前缀处理"]},{"title":"README","url":"/2022/11/26/README/","content":"<p>姓名：杨皓岚 学号:2021212359 班级：2022211304</p>"},{"title":"hexo","url":"/2022/08/01/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","categories":["hexo_infor"],"tags":["hexo"]},{"title":"z5亲身评测以及第一次扫街成果","url":"/2022/10/27/my-first-blog-in-github/","content":"<h3 id=\"1-z5第一次扫街成果-直出效果\"><a href=\"#1-z5第一次扫街成果-直出效果\" class=\"headerlink\" title=\"1.z5第一次扫街成果(直出效果)\"></a>1.z5第一次扫街成果(直出效果)</h3><h6 id=\"暗光下的表现\"><a href=\"#暗光下的表现\" class=\"headerlink\" title=\"暗光下的表现\"></a>暗光下的表现</h6><table>\n<thead>\n<tr>\n<th><img src=\"/2022/10/27/my-first-blog-in-github/2022.11.5-1.JPG\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>快门优先  f&#x2F;6.3  1&#x2F;80s  ISO-51200 曝光补偿:0  焦距:50mm</td>\n</tr>\n</tbody></table>\n<h6 id=\"局部暗与高光处的和谐过度，色彩宽容度高\"><a href=\"#局部暗与高光处的和谐过度，色彩宽容度高\" class=\"headerlink\" title=\"局部暗与高光处的和谐过度，色彩宽容度高\"></a>局部暗与高光处的和谐过度，色彩宽容度高</h6><table>\n<thead>\n<tr>\n<th><img src=\"/2022/10/27/my-first-blog-in-github/2022.11.5-2.JPG\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>手动 f&#x2F;8 1&#x2F;250s ISO-200 曝光补偿:0 焦距:50mm</td>\n</tr>\n</tbody></table>\n<h6 id=\"阳光下的局部暗处与亮处\"><a href=\"#阳光下的局部暗处与亮处\" class=\"headerlink\" title=\"阳光下的局部暗处与亮处\"></a>阳光下的局部暗处与亮处</h6><table>\n<thead>\n<tr>\n<th><img src=\"/2022/10/27/my-first-blog-in-github/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%89%AB%E8%A1%97_2022.11.5-056.JPG\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>手动 f&#x2F;9 1&#x2F;320s ISO-200 曝光补偿:0 焦距:47mm</td>\n</tr>\n</tbody></table>\n<h6 id=\"下图不知道为什么霓虹灯色散明显，但是整体效果还行\"><a href=\"#下图不知道为什么霓虹灯色散明显，但是整体效果还行\" class=\"headerlink\" title=\"下图不知道为什么霓虹灯色散明显，但是整体效果还行\"></a>下图不知道为什么霓虹灯色散明显，但是整体效果还行</h6><table>\n<thead>\n<tr>\n<th><img src=\"/2022/10/27/my-first-blog-in-github/%E7%AC%AC%E4%B8%89%E6%AC%A1%E9%95%BF%E6%9B%9D%E5%85%89%E5%B0%9D%E8%AF%95+%E6%9C%88%E5%85%A8%E9%A3%9F%E5%BB%B6%E6%97%B6%E6%8B%8D%E6%91%84_2022.11.7-022.JPG\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>快门优先 f&#x2F;6 1.6s ISO-125 曝光补偿:0 焦距:44mm</td>\n</tr>\n</tbody></table>\n<h6 id=\"以及拍星空的效果（光污染有点大，银河基本拍不出来）\"><a href=\"#以及拍星空的效果（光污染有点大，银河基本拍不出来）\" class=\"headerlink\" title=\"以及拍星空的效果（光污染有点大，银河基本拍不出来）\"></a>以及拍星空的效果（光污染有点大，银河基本拍不出来）</h6><table>\n<thead>\n<tr>\n<th><img src=\"/2022/10/27/my-first-blog-in-github/%E7%AC%AC%E4%B8%89%E6%AC%A1%E9%95%BF%E6%9B%9D%E5%85%89%E5%B0%9D%E8%AF%95+%E6%9C%88%E5%85%A8%E9%A3%9F%E5%BB%B6%E6%97%B6%E6%8B%8D%E6%91%84_2022.11.7-012.JPG\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>手动 f&#x2F;4 30s ISO-100 曝光补偿:0 焦距:24mm</td>\n</tr>\n</tbody></table>\n<h6 id=\"蓝天与树与屋檐\"><a href=\"#蓝天与树与屋檐\" class=\"headerlink\" title=\"蓝天与树与屋檐\"></a>蓝天与树与屋檐</h6><table>\n<thead>\n<tr>\n<th><img src=\"/2022/10/27/my-first-blog-in-github/%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%89%AB%E8%A1%97_2022.11.12-017.JPG\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>手动 f&#x2F;20 1&#x2F;1600s ISO-2500 曝光补偿:0 焦距:50mm</td>\n</tr>\n</tbody></table>\n<h6 id=\"虚化效果（有点过曝了）\"><a href=\"#虚化效果（有点过曝了）\" class=\"headerlink\" title=\"虚化效果（有点过曝了）\"></a>虚化效果（有点过曝了）</h6><table>\n<thead>\n<tr>\n<th><img src=\"/2022/10/27/my-first-blog-in-github/%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%89%AB%E8%A1%97_2022.11.12-029.JPG\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>手动 f&#x2F;8 1&#x2F;400s ISO-2500 曝光补偿:0 焦距:50mm</td>\n</tr>\n</tbody></table>\n<h6 id=\"高光下的梧桐叶-天空也有点过曝了\"><a href=\"#高光下的梧桐叶-天空也有点过曝了\" class=\"headerlink\" title=\"高光下的梧桐叶(天空也有点过曝了)\"></a>高光下的梧桐叶(天空也有点过曝了)</h6><table>\n<thead>\n<tr>\n<th><img src=\"/2022/10/27/my-first-blog-in-github/%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%89%AB%E8%A1%97_2022.11.12-030.JPG\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>自动 f&#x2F;11 1&#x2F;800s ISO-2500 曝光补偿:0 焦距:50mm</td>\n</tr>\n</tbody></table>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>​\t\tz5总的来说是一款合格的入门级微单，仅仅搭配24-50mm的镜头就能带给我这么多惊喜，未来搭配上50mm f&#x2F;1.8拍人像，24-120mm拍风景的时候效果估计会更好。敬请期待我之后的扫街成果吧！</p>","categories":["Photography"],"tags":["无聊产出","构图"]}]